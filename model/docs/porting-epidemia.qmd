---
title: "Porting An Existing Model (Epidemia) To MSR"
format: gfm
engine: jupyter
---

\newpage

# Introduction

\lettrine[lines=5, depth=0]{O}{ne} aim of the Multisignal Signal Renewal (hereafter referred to as MSR[^msr_v_pyrenew]) project is to make [statistical inference](https://en.wikipedia.org/wiki/Statistical_inference) and [simulation](https://en.wikipedia.org/wiki/Simulation) (mostly within the context of infectious disease modeling) more flexible. With flexible infectious disease model tooling, one might expect to be able to re-implement existing, external infectious disease models. Such capabilities are possible with MSR.

[^msr_v_pyrenew]: The author of this tutorial prefers the use of MSR to `pyrenew`, which the reader may have seen used in other MSR tutorials.

In this walk-through, the author will demonstrate how to re-implement a model (hereafter referred to as `cfaepim`[^cfaepim]) created for influenza forecasting using the [Epidemia](https://github.com/CDCgov/multisignal-epi-inference) framework. Beyond re-implementing the models, the author also compares their discrepancies on daily influenza incidence data from [NHSN](https://healthdata.gov/Hospital/COVID-19-Reported-Patient-Impact-and-Hospital-Capa/g62h-syeh)[^flusight].

[^flusight]: For forecasts from influenza models using this data, see [here](https://github.com/cdcepi/FluSight-forecasts). For more information regarding how this data has been used for influenza forecasting, see [here](https://github.com/cdcepi/FluSight-forecast-hub/tree/main/target-data).

[^cfaepim]: The `cfaepim` model is contained with private CDC repository; however, the author of this tutorial has received permission to reproduce the parts of the model code from [the author](https://github.com/dylanhmorris) of the repository.

# Know-Requisites

First, if you have not already installed MSR, please do the following: `pip3 install` followed by a space and then

```
git+https://github.com/CDCgov/multisignal-epi-inference@main#subdirectory=model
```

Ideally, this tutorial should not be the first tutorial you engage with in trying to get a sense of MSR's utility. Leading up to this tutorial, the author believes it is reasonable for the reader to proceed through _at least_ the following tutorials beforehand, in descending order:

* [Pyrenew Demo](https://cdcgov.github.io/multisignal-epi-inference/tutorials/pyrenew_demo.html)
* [Getting Started](https://cdcgov.github.io/multisignal-epi-inference/tutorials/getting-started.html)
* [Extending Pyrenew](https://cdcgov.github.io/multisignal-epi-inference/tutorials/extending_pyrenew.html)
* [Fitting A Hospital Admissions-Only Model](https://cdcgov.github.io/multisignal-epi-inference/tutorials/example-with-datasets.html)


## Terms

The reader might find having the definitions of the following terms useful.

__Basic Reproduction Number__ [@van2002reproduction, pp. 32-33]

> The basic reproduction number, denoted $\mathscr{R}_0$, is 'the expected number of secondary cases produced, in a completely susceptible population, by a typical infective individual' [2]; see also [5, p. 17]. If $\mathscr{R}_0 < 1$, then on average an infected individual produces less than one new infected individual over the course of its infectious period, and the infection cannot grow. Conversely, if $\mathscr{R}_0 > 1$, then each infected individual produces, on average, more than one new infection, and the disease can invade the population. For the case of a single infected compartment, $\mathscr{R}_0$ is simply the product of the infection rate and the mean duration of the infection. However, for more complicated models with several infected compartments this simple heuristic definition of $\mathscr{R}_0$ is insufficient. A more general basic reproduction number can be defined as the number of new infections produced by a typical infective individual in a population at a [disease free equilibrium (DFE)].

__Generation Interval__ [@champredon2018equivalence, pp.3258 and pp.3267, respectively]

> The generation interval is the interval between the time when an individual is infected by an infector and the time when this infector was infected.

and

> The generation interval is rarely observed (because the actual transmission time is usually not observed), but through contact tracing it is possible to directly observe the _serial interval_ (i.e., the interval of time between the onset of symptoms for the infector and her/his infectee).

<!-- __Stochastic Process__ []
__Renewal Process__ [] -->


__Renewal Equation__ (Historical) [@champredon2018equivalence, pp.3258,3267]

> The renewal equation was introduced by Euler in 1767 [@euler1767recherches] in his work on population dynamics and was reframed in a modern continuous formulation by Lotka in 1907 [@lotka1907relation]. Lotka's formulation is usually expressed as $$B(t) = \int^{\infty}_0 B(t-a) p(a) \nu(a) da$$ where $B(t)$ is the number of births at time $t$, $p(a)$ is the probability of survival to age $a$, and $\nu(a)$ is the fertility at age $a$. This equation was derived for demographic studies and has been adapted to epidemics using an "age of infection" model that was described in the seminal work of Kermack and McKendrick in 1927 [@kermack1927contribution]. This epidemic model changes the interpretation of the variables: $B(t)$ represents the number of new infectious individuals at time $t$, $p(a)$ the probability to be infectious a time units after acquiring the disease, and $\nu(a)$ the "transmission potential" that is, the average number of secondary infections at "infection age" $a$.

__Renewal Equation__ (Epidemiology) [@pakkanen2023unifying, pp.35]

> The form of this renewal equation when only considering $\mathscr{R}_0$ is exactly what is commonly used in epidemic modelling where the incidence of infections $I(t)$ follows a renewal equation given by $$I(t) = \mathscr{R}_0 \int_0^{\infty} I(t-u)g(u)du$$ where $g(\cdot)$ is the probability density function (PDF) of the generation interval. Introducing a time-varying reproduction number $\mathscr{R}(t)$ within the Bellman–Harris process in general does not simply entail replacing $\mathscr{R}_0$ with $\mathscr{R}(t)$ in the renewal equation.

# Short Tour Of The Data

Before proceeding further, a check in of the data is warranted:

[PLACEHOLDER]

<!-- ![Description](path){ width=50% }  -->

# Short Tour Of Epidemia

The following comes from Epidemia's Introduction page:

> The open-source R (R Core Team [2020](https://imperialcollegelondon.github.io/epidemia/articles/model-introduction.html#ref-rcore_2011)) package **epidemia** provides a framework for Bayesian, regression-oriented modeling of the temporal dynamics of infectious diseases. Typically, but not exclusively, these models are fit to areal time-series; i.e. aggregated event counts for a given population and period. Disease dynamics are described explicitly; observed data are linked to latent infections, which are in turn modeled as a self-exciting process tempered by time-varying reproduction numbers. Regression models are specified for several objects in the model. For example, reproduction numbers are expressed as a transformed predictor, which may include both covariates and autoregressive terms. A range of prior distributions can be specified for unknown parameters by leveraging the functionality of **rstanarm** (Goodrich et al. [2020](https://imperialcollegelondon.github.io/epidemia/articles/model-introduction.html#ref-goodrich_2020)). Multilevel models are supported by partially pooling covariate effects appearing in the predictor for reproduction numbers between multiple populations.

While not necessary for this understanding tutorial, perusing the following pages on Epidemia might aid the reader:

* [Epidemia's Website](https://imperialcollegelondon.github.io/epidemia/index.html)
* [Epidemia Model Description Page](https://imperialcollegelondon.github.io/epidemia/articles/model-description.html)
* [Epidemia Model Schematic Page](https://imperialcollegelondon.github.io/epidemia/articles/model-schematic.html)
* [Epidemia Model Implementation Page](https://imperialcollegelondon.github.io/epidemia/articles/model-implementation.html)

Given `cfaepim` is an influenza forecasting model, the author describes the Epidemia modeling approach (following the language used in Epidemia's Model Description page) with influenza data in mind.

<!-- Consider the United States (US) as consisting of a single homogeneous population. This population can be stratified by the US's 50 states and additional territories (e.g., Puetro Rico). -->

Suppose, over some interval of time, we observe daily influenza hospitalization counts for some region. This non-negative time series be represented as $Y = (Y_1, \dotsc, Y_n)$, where $Y_i$ represents the influenza hospitalization count for day $i$. Note that $Y_t$, i.e. the influenza hospitalization count for day $t$ can be...

> ...modeled as deriving from past new infections is, $s<t$, and some parameter $\alpha_t>0$, a multiplier, which in most contexts represents an instantaneous _ascertainment rate_. The general model can be expressed as $$Y_t \sim p(y_t, \phi)$$ $$y_t = \alpha_t \sum_{s<t}i_s \pi_{t-s}$$ where $y_t$ is the expected value of the data distribution and $\phi$ is an auxiliary parameter. $\pi_k$ is typically the time distribution from an infection to an observation, which we refer to as the infection to observation distribution. More generally, however, $\pi_k$ can be used to obtain any linear combination of past infections. New infections $i_t$ at times $t>0$ are modeled through a renewal equation, and are tempered by a non-negative parameter $\mathscr{R}_t$ which represents the reproduction number at time $t$. Formally $$i_t = \mathscr{R}_t \sum_{s<t}i_s g_{t-s}$$ where $g_k$ is a probability mass function for the time between infections. The recursion is initialized with seeded infections $i_{v:0}, v<0$, which are treated as unknown parameters. All parameters are assigned priors, i.e. $$i_{v:0},\mathscr{R},\phi,\alpha \sim p(\cdot)$$ where $\mathscr{R} = (\mathscr{R}_1,\dotsc,\mathscr{R}_n)$ and $\alpha=(\alpha_1,\dotsc,\alpha_n)$. The posterior distribution is then proportional to prior and likelihood, i.e.  $$p(i_{v:0},\mathscr{R},\phi,\alpha∣Y)\propto p(i_{v:0})p(\mathscr{R})p(\phi)p(\alpha)\prod_t p(Y_t∣y_t,\phi)$$.

In the description above, the reader is confronted with some questions:

* What choice if sampling distribution $p(y_t, \phi)$ should be made?
* What priors $p(\cdot)$ are adequate, given existing uncertainties?
* What considerations are there for handling susceptibles?
* How should transmission be modelled, i.e. choosing $\mathscr{R}$?
* What are appropriate link functions for $g$?

These questions will be addressed in the following section.

# Epidemia Forecasting In Influenza

Creating models in Epidemia general involves setting up a transmission component and an observation component, and then bringing the latter two together while also addressing other needs, e.g. the link function $g$.

<!--
Use parameters and priors

-->



## Transmission Component

In `cfaepim`, the transmission component is built in the following manner:

```r
#' Build the R(t) component of a "covariate
#' light" epidemia model.
#'
#' @param rt_intercept_prior_mode prior mode
#' for R(t) intercept. Prior is Normal on the
#' transformed (scaled logit) scale.
#' @param rt_intercept_prior_scale prior standard
#' deviation (scale) for R(t) intercept. Prior is
#' Normal on the transformed (scaled logit) scale.
#' @param max_rt Maximum permitted R(t) value (upper
#' limit of the scaled logit), on the natural scale.
#' R(t) will be permitted to range between 0 and
#' this value.
#' @param rw_prior_scale prior standard deviation
#' (scale parameter) for the random walk on R(t).
#' Random walk steps are Normal on the transformed
#' (scaled logit) scale.
#' @return the R(t) model, as the output
#' of an [epidemia::epirt()] call.
#' @export
build_light_rt <- function(rt_intercept_prior_mode,
                           rt_intercept_prior_scale,
                           max_rt,
                           rw_prior_scale) {
  rt_model <- epidemia::epirt(
    formula = as.formula(
      sprintf(
        paste0(
          "R(location, date) ~ 1 + ",
          "rw(time = week, gr = location, prior_scale = %f)"
        ),
        rw_prior_scale
      )
    ),
    prior_intercept = rstanarm::normal(
      location = rt_intercept_prior_mode,
      scale = rt_intercept_prior_scale
    ),
    link = epidemia::scaled_logit(K = max_rt)
  )
  return(rt_model)
}
```

## Observation Component

In `cfaepim`, the observation component is built in the following manner:

```r

#' Build the observation component of a "covariate
#' light" epidemia model.
#'
#' @param inf_to_hosp_dist infection to hospitalization
#' delay distribution, passed as the `i2o` parameter
#' to [epidemia::epiobs()].
#' @param ihr_intercept_prior_mode Normal prior mode for
#' the overall infection (observed) hospitalization rate
#' (i.e. the probability that an arbitrary infected individual
#' gets observed admitted to the hospital), before taking
#' into account any covariates.
#' Specified on the transformed scale (see `link` parameter).
#' @param ihr_intercept_prior_scale Normal prior scale for the
#' intercept of the regression predicting the
#' infection (observed) hospitalization rate
#' (i.e. the probability that an arbitrary infected individual
#' gets observed admitted to the hospital), before taking
#' into account any covariates.
#' Specified on the transformed scale (see `link` parameter).
#' @param day_of_week_eff_prior_modes Normal prior
#' modes for the day of the week effect on observation
#' probability, relative to the reference day of the week.
#' Should be a vector of length 6.
#' Specified on the transformed scale (see `link` parameter).
#' @param day_of_week_eff_prior_scales Normal prior
#' scales for the day of the week effect on observation
#' probability, relative to the reference day of the week.
#' Should be a vector of length 6.
#' Specified on the transformed scale (see `link` parameter).
#' @param non_obs_effect_prior_mode Normal prior
#' mode for the change in the observation probability
#' during the nonobservation (seeding) period. Useful
#' for model initialization. Should typically be a large
#' negative number.
#' Specified on the transformed scale (see `link` parameter).
#' @param non_obs_effect_prior_scale Normal prior
#' scalefor the change in the observation probability
#' during the nonobservation (seeding) period. Useful
#' for model initialization. Should typically be a small
#' number, to enforce the large negative effect given in
#' non_obs_effect_prior_mode.
#' Specified on the transformed scale (see `link` parameter).
#' @param inv_dispersion_prior_mode Normal prior mode
#' for the reciprocal dispersion of the negative binomial
#' observation process.
#' @param inv_dispersion_prior_mode Normal prior scale
#' for the reciprocal dispersion of the negative binomial
#' observation process.
#' @param link link function for the observation model,
#' passed as the `link` parameter to [epidemia::epiobs()]
#' Default `"logit"`.
#' @return the observation model, as the output
#' of an [epidemia::epiobs()] call.
#' @export
build_light_obs <- function(inf_to_hosp_dist,
                            ihr_intercept_prior_mode,
                            ihr_intercept_prior_scale,
                            day_of_week_eff_prior_modes,
                            day_of_week_eff_prior_scales,
                            holiday_eff_prior_mode,
                            holiday_eff_prior_scale,
                            post_holiday_eff_prior_mode,
                            post_holiday_eff_prior_scale,
                            non_obs_effect_prior_mode,
                            non_obs_effect_prior_scale,
                            inv_dispersion_prior_mode,
                            inv_dispersion_prior_scale,
                            link = "logit") {
  return(epidemia::epiobs(
    formula = as.formula(paste0(
      "hosp ~ 1 + day_of_week + ",
      "is_holiday + ",
      "is_post_holiday + ",
      "nonobservation_period"
    )),
    ## Add a covariate for the
    ## nonobservation window to
    ## leave an initial evolution
    ## period with no observations
    i2o = inf_to_hosp_dist,
    link = link,
    family = "neg_binom",
    prior_intercept = rstanarm::normal(
      location = ihr_intercept_prior_mode,
      scale = ihr_intercept_prior_scale
    ),
    prior = rstanarm::normal(
      location = c(
        day_of_week_eff_prior_modes,
        holiday_eff_prior_mode,
        post_holiday_eff_prior_mode,
        non_obs_effect_prior_mode
      ),
      ## a large negative non_obs_effect
      ## effectively conditions on detection
      ## prob = 0 outside the observation period
      scale = c(
        day_of_week_eff_prior_scales,
        holiday_eff_prior_scale,
        post_holiday_eff_prior_scale,
        non_obs_effect_prior_scale
        ## non-obs prior scale
        ## should be small to
        ## enforce non-obs effect
        ## close to (large negative) mode
      )
    ),
    prior_aux = rstanarm::normal(
      location = inv_dispersion_prior_mode,
      scale = inv_dispersion_prior_scale
    )
  ))
}
```

## Influenza Model

In `cfaepim`, the influenza model "covariate light" is built in the following manner:

```r
#' Build a complete "covariate light" epidemia
#' model
#'
#' For the given state with
#' the given parameter list
#'
#' @param state state for which to build the model
#' @param clean_data data frame of all fitting data
#' @param params the parameter list
#' @param n_warmup number of warmup samples for Stan to draw per chain.
#' Default `1000`.
#' @param n_iter total number of iterations for Stan per chain.
#' Default `2000`.
#' @param n_chains number of separate NUTS chains to run.
#' Default `4`.
#' @param max_treedepth maximum treedepth for NUTS,
#' passed to [rstan::sampling()]. Default `11`.
#' @param adapt_delta target acceptance probability
#' for NUTS adaptation, passed to [rstan::sampling()].
#' Default `0.85`.
#' @param refresh How often to print Stan progress
#' to terminal. Default `0` (never).
#' @return a list of arguments that can be passed
#' to [epidemia::epim()]
#' @export
build_state_light_model <- function(
    state,
    clean_data,
    params,
    n_warmup = 1000,
    n_iter = 2000,
    n_chains = 4,
    max_treedepth = 11,
    adapt_delta = 0.85,
    refresh = 0) {
  rw_prior_scale <- params$weekly_rw_prior_scale

  rt_model <- build_light_rt(
    params$rt_intercept_prior_mode,
    params$rt_intercept_prior_scale,
    params$max_rt,
    params$weekly_rw_prior_scale
  )

  ## make sure day_of_week is properly
  ## set up as a factor
  dow_levels <- levels(
    lubridate::wday("2023-01-01",
      label = TRUE,
      week_start = params$reference_day_of_week
    )
  )
  clean_data <- clean_data |>
    dplyr::mutate(
      day_of_week = factor(day_of_week,
        ordered = FALSE,
        levels = dow_levels
      )
    )
  # create the mean infections per day to use in prior_seeds
  # to population adjust the seeded infections
  mode_ihr <- plogis(params$ihr_intercept_prior_mode)
  state_data <- clean_data |>
    dplyr::filter(location == !!state)

  mean_inf_df <- state_data |>
    dplyr::distinct(location, population, first_week_hosp) |>
    dplyr::mutate(
      mean_seed_inf_per_day = (
        (params$inf_model_prior_infections_per_capita * population) +
          (first_week_hosp / (!!mode_ihr * 7))
      )
    )
  mean_inf_val <- mean_inf_df$mean_seed_inf_per_day[1]
  infection_model <- epidemia::epiinf(
    params$generation_time_dist,
    seed_days = params$inf_model_seeds,
    prior_seeds = rstanarm::exponential(1 / mean_inf_val),
    pop_adjust = TRUE,
    pops = "population",
    prior_susc = rstanarm::normal(
      location = params$susceptible_fraction_prior_mode,
      scale = params$susceptible_fraction_prior_scale
    )
  )
  obs_model <- build_light_obs(
    params$inf_to_hosp_dist,
    params$ihr_intercept_prior_mode,
    params$ihr_intercept_prior_scale,
    params$day_of_week_effect_prior_modes,
    params$day_of_week_effect_prior_scales,
    params$holiday_eff_prior_mode,
    params$holiday_eff_prior_scale,
    params$post_holiday_eff_prior_mode,
    params$post_holiday_eff_prior_scale,
    params$non_obs_effect_prior_mode,
    params$non_obs_effect_prior_scale,
    params$reciprocal_dispersion_prior_mode,
    params$reciprocal_dispersion_prior_scale
  )
  stan_data <- state_data |>
    dplyr::select(
      date,
      location,
      population,
      hosp,
      day_of_week,
      is_holiday,
      is_post_holiday,
      recency,
      nonobservation_period,
      week
    )
  aug_stan_data <- add_pre_observation_period(
    stan_data,
    params$n_pre_observation_days
  )
  epim_args <- list(
    rt = rt_model,
    obs = obs_model,
    inf = infection_model,
    data = aug_stan_data,
    warmup = n_warmup,
    iter = n_iter,
    seed = params$seed,
    chains = n_chains,
    refresh = refresh,
    control = list(
      max_treedepth = max_treedepth,
      adapt_delta = adapt_delta
    )
  )
  return(epim_args)
}
```

## Parameters & Priors

Although the author has not yet presented the parameters chosen, representing them now seems likely to help interpret the subsequent code sections.

For some of these,


```yaml
day_of_week_effect_prior_modes = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
day_of_week_effect_prior_scales = [0.25, 0.25, 0.25, 0.25, 0.25, 0.25]
holiday_eff_prior_mode = -0.2
holiday_eff_prior_scale = 0.2
post_holiday_eff_prior_mode = 0.0
post_holiday_eff_prior_scale = 0.2
recency_eff_prior_mode = 0.0
recency_eff_prior_scale = 0.1
recency_effect_length = 0

generation_time_dist = [0.233, 0.359, 0.198, 0.103, 0.053, 0.027, 0.014, 0.007, 0.003, 0.002, 0.001]
ihr_intercept_prior_mode = -6.5
ihr_intercept_prior_scale = 0.5
inf_model_prior_infections_per_capita = 0.0001
inf_model_seeds = 8
inf_to_hosp_dist = [0.05, 0.1, 0.175, 0.225, 0.175, 0.125, 0.075, 0.05, 0.025]
max_rt = 3.0
n_pre_observation_days = 14
non_obs_effect_prior_mode = -50
non_obs_effect_prior_scale = 0.01
reciprocal_dispersion_prior_mode = 10
reciprocal_dispersion_prior_scale = 5
reference_day_of_week = 4
rt_intercept_prior_mode = -0.4054651
rt_intercept_prior_scale = 0.3
seed = 54321
susceptible_fraction_prior_mode = 0.9
susceptible_fraction_prior_scale = 0.1
weekly_rw_prior_scale = 0.25
first_fitting_date = "2023-09-15"

[mcmc]
adapt_delta = 0.9
max_treedepth = 12
n_chains = 1
n_warmup = 1000
n_iter = 2000
```

## Example Output

# Resources



# References

<!-- MSR allows users to simulate basic [renewal processes](https://en.wikipedia.org/wiki/Renewal_theory). -->


<!-- Outline:

* An Epidemia Model For Influenza
* Preparing Data For MSR
* Model Validation And Comparison -->


<!--
- \usepackage{minted}
- \setminted[python]{breaklines=true, tabsize=4}
- \setminted[r]{breaklines=true, tabsize=2}

- \usepackage{float}
- \let\origfigure\figure
- \let\endorigfigure\endfigure
- \renewenvironment{figure}[1][H]{\origfigure[H]}{\endorigfigure}
-
- - \setminted[python]{frame=single, framesep=2mm, rulecolor=\color{black}, numbersep=5pt, breaklines=true, tabsize=4, linenos=false, xleftmargin=5mm, xrightmargin=5mm}
-
- \inputminted{python}{./source/code/example.py}
-
def load_NHSN(data_path: str):
    """
    Loads NHSN hospitalization data from tsv file
    path.

    Parameters
    ----------
    data_path : str
        The path to the tsv file to be read.

    Returns
    -------
    pl.DataFrame
        A polars dataframe of NHSN hospitalization
        data.
    """
    return pl.read_csv(data_path, separator="\t", infer_schema_length=10000)-->
