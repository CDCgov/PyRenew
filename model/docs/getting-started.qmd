---
title: "Getting started with pyrenew"
format: gfm
engine: jupyter
---

`pyrenew` is a flexible tool for simulation and inference of epidemiological models with an emphasis on renewal models. Built on top of `numpyro`, `pyrenew` provides core components for model building as well as pre-defined models for processing various types of observational processes. This document illustrates how `pyrenew` can be used to build a basic renewal model.

## 'Hello world' model

In this section, we will show the steps to build a simple renewal model featuring a latent infection process, a random walk Rt process, and an observation process for the reported infections. We start by loading the needed components to build a basic renewal model:

```{python}
#| label: loading-pkgs
#| output: false
#| warning: false
import jax.numpy as jnp
import numpy as np
import numpyro as npro
from pyrenew.process import RtRandomWalkProcess
from pyrenew.latent import Infections, Infections0
from pyrenew.observation import PoissonObservation
from pyrenew.deterministic import DeterministicPMF
from pyrenew.model import RtInfectionsRenewalModel
```

In the basic renewal model we can define five components: generation interval, baseline infections, Rt, latent infections, and observed infections.

```{python}
#| label: creating-elements
# (1) The generation interval (deterministic)
gen_int = DeterministicPMF(
    (jnp.array([0.25, 0.25, 0.25, 0.25]),),
)

# (2) Baseline infections (inferred with a prior)
I0 = Infections0()

# (3) The random process for Rt
rt_proc = RtRandomWalkProcess()

# (4) Latent infection process (which will use 1 and 2)
latent_infections = Infections()

# (5) The observed infections process (with mean at the latent infections)
observed_infections = PoissonObservation(
    rate_varname='latent',
    counts_varname='observed_infections',
    )
```

With these five pieces, we can build the basic renewal model:

```{python}
#| label: model-creation
model1 = RtInfectionsRenewalModel(
    gen_int=gen_int,
    I0=I0,
    Rt_process=rt_proc,
    latent_infections=latent_infections,
    observed_infections=observed_infections,
    )
```

The following diagram summarizes how the modules interact via composition; notably, `gen_int`, `I0`, `rt_proc`, `latent_infections`, and `observed_infections` are instances of `RandomVariable`, which means these can be easily replaced to generate different version of `RtInfectionsRenewalModel`:

```{mermaid}
%%| label: overview-of-RtInfectionsRenewalModel
flowchart TB
    genint["(1) gen_int\n(DetermnisticPMF)"]
    i0["(2) I0\n(Infections0)"]
    rt["(3) rt_proc\n(RtRandomWalkProcess)"]
    inf["(4) latent_infections\n(Infections)"]
    obs["(5) observed_infections\n(PoissonObservation)"]

    model1["model1\n(RtInfectionsRenewalModel)"]

    i0-->|Composes|model1
    genint-->|Composes|model1
    rt-->|Composes|model1
    obs-->|Composes|model1
    inf-->|Composes|model1
```

Using `numpyro`, we can simulate data using the `sample()` member function of `RtInfectionsRenewalModel`:

```{python}
#| label: simulate
np.random.seed(223)
with npro.handlers.seed(rng_seed=np.random.randint(1, 60)):
    sim_data = model1.sample(constants=dict(n_timepoints=30))

sim_data
```

The `sample()` method of the `RtInfectionsRenewalModel` returns a list composed of the `Rt` and `infections` sequences.

```{python}
#| label: basic-fig
#| fig-cap: Rt and Infections
#| fig-cap-location: bottom
import matplotlib.pyplot as plt

fig, axs = plt.subplots(1, 2)

# Rt plot
axs[0].plot(range(0, 31), sim_data[0])
axs[0].set_ylabel('Rt')

# Infections plot
axs[1].plot(range(0, 31), sim_data[1])
axs[1].set_ylabel('Infections')

fig.suptitle('Basic renewal model')
fig.supxlabel('Time')
plt.tight_layout()
plt.show()
```

To fit the model, we can use the `run()` method of the model `RtInfectionsRenewalModel`; an inherited method from the metaclass `Model`:

```{python}
#| label: model-fit
import jax

model_data = {'n_timepoints': len(sim_data[1])-1}

model1.run(
    num_warmup=2000,
    num_samples=1000,
    random_variables=dict(observed_infections=sim_data.observed),
    constants=model_data,
    rng_key=jax.random.PRNGKey(54),
    mcmc_args=dict(progress_bar=False),
    )
```

Now, let's investigate the output, particularly, the posterior distribution of the Rt estimates:

```{python}
#| label: output-rt
#| fig-cap: Rt posterior distribution
#| fig-cap-location: bottom
import polars as pl
samps = model1.spread_draws([('Rt', 'time')])

fig, ax = plt.subplots(figsize=[4, 5])

ax.plot(sim_data[0])
samp_ids = np.random.randint(size=25, low=0, high=999)
for samp_id in samp_ids:
    sub_samps = samps.filter(pl.col("draw") == samp_id).sort(pl.col('time'))
    ax.plot(sub_samps.select("time").to_numpy(),
            sub_samps.select("Rt").to_numpy(), color="darkblue", alpha=0.1)
ax.set_ylim([0.4, 1/.4])
ax.set_yticks([0.5, 1, 2])
ax.set_yscale("log")
```

## Architecture of pyrenew

`pyrenew` leverages `numpyro`'s flexibility to build models via composition. As a principle, most objects in `pyrenew` can be treated as random variables from which we can sample. At the top-level `pyrenew` has two metaclass from which most objects inherit: `RandomVariable` and `Model`. From them, the following four sub-modules arise:

-   The `process` sub-module,
-   The `deterministic` sub-module,
-   The `observation` sub-module,
-   The `latent` sub-module, and
-   The `models` sub-module

Where the first four are collections of instances of `RandomVariable` and the last one a collection of instances of `Model`. The following diagram shows a detailed view of how meta classes, modules, and classes interact to create the `RtInfectionsRenewalModel` instantiated in the previous section:

```{mermaid}
%%| label: overview-of-RtInfectionsRenewalModel
flowchart LR
    rand((RandomVariable\nmetaclass))
    models((Model\nmetaclass))

    subgraph observations[Observations module]
        obs["observed_infections\n(PoissonObservation)"]
    end

    subgraph latent[Latent module]
        inf["latent_infections\n(Infections)"]
        i0["I0\n(Infections0)"]
    end

    subgraph process[Process module]
        rt["rt_proc\n(RtRandomWalkProcess)"]
    end

    subgraph deterministic[Deterministic module]
        detpmf["gen_int\n(DeterministicPMF)"]
    end

    subgraph model[Model module]
        model1["model1\n(RtInfectionsRenewalModel)"]
    end

    rand-->|Inherited by|observations
    rand-->|Inherited by|process
    rand-->|Inherited by|latent
    rand-->|Inherited by|deterministic
    models-->|Inherited by|model

    detpmf-->|Composes|model1
    i0-->|Composes|model1
    rt-->|Composes|model1
    obs-->|Composes|model1
    inf-->|Composes|model1
```
