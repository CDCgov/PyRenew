---
title: Pyrenew demo
format: gfm
engine: jupyter
---

This demo simulates some basic renewal process data and then fits to it using `pyrenew`.

Assuming you've already installed Python and pip, you’ll need to first install `pyrenew`:

```{python}
pip install pyrenew
```

You’ll also need working
installations of `matplotlib`, `numpy`, `jax`, `numpyro`, and `polars`:

```{python}
pip install matplotlib numpy jax numpyro polars
```

To begin, run the following import section to call external modules and functions necessary to run the `pyrenew` demo. The `import` statement imports the module and the `as` statement renames the module for use within this script. The `from` statement imports a specific function from a module (named after the `.`) within a package (named before the `.`).

```{python}
#| output: false
#| label: loading-pkgs
#| warning: false
import matplotlib as mpl
import matplotlib.pyplot as plt
import jax
import jax.numpy as jnp
import numpy as np
from numpyro.handlers import seed
import numpyro.distributions as dist
```

```{python}
from pyrenew.process import SimpleRandomWalkProcess
```

To understand the simple random walk process underlying the sampling within the renewal process model, we first examine a single random walk path. Using the `sample` method from an instance of the `SimpleRandomWalkProcess` class, we first create an instance of the `SimpleRandomWalkProcess` class with a normal distribution of mean = 0 and standard deviation = 0.0001 as its input. Next, the `with` statement sets the seed for the random number generator for the duration of the block that follows. Inside the `with` block, the `q_samp = q.sample(duration=100)` generates the sample instance over a duration of 100 time units. Finally, this single random walk process is visualized using `matplot.pyplot` to plot the exponential of the sample instance.

```{python}
#| label: fig-randwalk
#| fig-cap: Random walk example
np.random.seed(3312)
q = SimpleRandomWalkProcess(dist.Normal(0, 0.001))
with seed(rng_seed=np.random.randint(0,1000)):
    q_samp = q.sample(duration=100)

plt.plot(np.exp(q_samp[0]))
# Damon: why is q_samp multideminsional?
# Damon: Why do we generate a Normal random walk and exponentiate? Should we have a Log-Normal Random walk function?
# Damon: Why do we generate random number to use as the rng seed?
# Damon: Description could be updated to relate our example to a real world scenario. What are we simulating here?
```

Damon: I believe the next section is totally separate from this first example. Perhaps we could make this clearer with # Section Labels.
Next, import several additional functions from the `latent` module of the `pyrenew` package to model infections, hospital admissions, initial infections, and hospitalization rate due to infection.

```{python}
from pyrenew.latent import (
    Infections, HospitalAdmissions, Infections0, InfectHospRate,
)
```

Additionally, import several classes from Pyrenew, including a Poisson observation process, determininstic PMF and variable classes, the Pyrenew hospitalization model, and a renewal modle (Rt) random walk process:

```{python}
from pyrenew.observation import PoissonObservation
from pyrenew.deterministic import DeterministicPMF, DeterministicVariable
from pyrenew.model import HospitalizationsModel
from pyrenew.process import RtRandomWalkProcess
```

To initialize the model, we first define initial conditions, including:

1) deterministic generation time, defined as an instance of the `DeterministicPMF` class, which gives the probability of each possible outcome for a discrete random variable given as a JAX NumPy array of four possible outcomes

2) initial infections at the start of simulation as a log-normal distribution with mean = 0 and standard deviation = 1

3) latent infections as an instance of the `Infections` class with default settings

4) latent hospitalization process, modeled by first defining the time interval from infections to hospitalizations as a `DeterministicPMF` input with 18 possible outcomes and corresponding probabilities given by the values in the array. The `HospitalAdmissions` function then takes in this defined time interval, as well as defining the rate at which infections are admitted to the hospital due to infection, modeled as a log-normal distribution with mean = `jnp.log(0.05)` and standard deviation = 0.05.

5) hospitalization observation process, modeled with a  Poisson distribution

6) an Rt random walk process with default settings

```{python}
# Initializing model components:

# 1) A deterministic generation time
gen_int = DeterministicPMF(
    (jnp.array([0.25, 0.25, 0.25, 0.25]),),
    )

# 2) Initial infections
I0 = Infections0(I0_dist=dist.LogNormal(0, 1))

# 3) The latent infections process
latent_infections = Infections()

# 4) The latent hospitalization process:

# First, define a deterministic infection to hosp pmf
inf_hosp_int = DeterministicPMF(
    (jnp.array([0, 0, 0,0,0,0,0,0,0,0,0,0,0, 0.25, 0.5, 0.1, 0.1, 0.05]),),
    )

# These sum to 1, so I assume they are probabilities, but what is the domain of the distribution?
# Regardless, a single array doesn't seem like the appropriate data structure to use.
latent_hospitalizations = HospitalAdmissions(
    infection_to_admission_interval=inf_hosp_int,
    infect_hosp_rate_dist = InfectHospRate(
            dist=dist.LogNormal(jnp.log(0.05), 0.05),
            ),
    )

# 5) An observation process for the hospitalizations
observed_hospitalizations = PoissonObservation()
# Damon: What does it mean that there is a PoissonObservation? What are the parameters of the Poisson distrubtion?

# 6) A random walk process (it could be deterministic using
# pyrenew.process.DeterministicProcess())
Rt_process = RtRandomWalkProcess()
# What's the difference between this and the SimpleRandomWalkProcess used earlier? Why don't we need to specify a distribution this time?
```

The `HospitalizationsModel` is then initialized using the initial conditions just defined:

```{python}
# Initializing the model
hospmodel = HospitalizationsModel(
    gen_int=gen_int,
    I0=I0,
    latent_hospitalizations=latent_hospitalizations,
    observed_hospitalizations=observed_hospitalizations,
    latent_infections=latent_infections,
    Rt_process=Rt_process
    )
# Damon: I don't really get why there is a hospitalizations model as a concept.
# Damon: Maybe the scope of the project is so limited that it makes sense, but one can easily imagine additional data sources (Wastewater, separate hosp and ICU admissions). Would each of those get a separate class?
```

Next, we sample from the `hospmodel` for 30 time steps and view the output of a single run:

```{python}
with seed(rng_seed=np.random.randint(1, 60)):
    x = hospmodel.sample(n_timepoints=30)
x
# Damon: Why do we generate random number to use as the rng seed?
```

Visualizations of the single model output show (top) infections over the 30 time steps, (middle) hospitalizations over the 30 time steps, and (bottom)

```{python}
#| label: fig-hosp
#| fig-cap: Infections
fig, ax = plt.subplots(nrows=3, sharex=True)
ax[0].plot(x.infections)
ax[0].set_ylim([1/5, 5])
ax[1].plot(x.latent)
ax[2].plot(x.sampled, 'o')
for axis in ax[:-1]:
    axis.set_yscale("log")
# Damon: We should label the figures.
```

To fit the `hospmodel` to the simulated data, we call `hospmodel.run()`, an MCMC algorithm, with the arguments generated in `hospmodel` object, using 1000 warmup stepts and 1000 samples to draw from the posterior distribution of the model parameters. The model is run for `len(x.sampled)-1` time steps with the seed set by `jax.random.PRNGKey()`
Damon: Which MCMC algorithm is run? Does it come from another module?
Damon: Where did we specify the prior distribution?

```{python}
# from numpyro.infer import MCMC, NUTS
hospmodel.run(
    num_warmup=1000,
    num_samples=1000,
    observed_hospitalizations=x.sampled,
    n_timepoints = len(x.sampled)-1,
    rng_key=jax.random.PRNGKey(54),
    mcmc_args=dict(progress_bar=False),
    )

# Damon: What is the relationship between `n_timepoints` and `observed_hospitalizations`? Is `n_timepoints` always one less than the number of hospitalization observtion times? If so, is this parameter redundant?
```

Print a summary of the model:

```{python}
hospmodel.print_summary()
```

Next, we will use the `spread_draws` function from the `pyrenew.mcmcutils` module to process the MCMC samples. The `spread_draws` function reformats the samples drawn from the `mcmc.get_samples()` from the `hospmodel`. The samples are simulated Rt values over time.

```{python}
from pyrenew.mcmcutils import spread_draws
samps = spread_draws(hospmodel.mcmc.get_samples(), [("Rt", "time")])
```

We visualize these samples below, with individual possible Rt estimates over time shown in light blue, and the overall mean estimate Rt shown in dark blue.
Damon: Phrasing could be improved on "individual possible Rt estimates." These are individual draws from the posterior R_t distribution.
Damon: also, we can use mathjax formatting to format R subscript t.

```{python}
#| label: fig-sampled-rt
#| fig-cap: Posterior Rt
import numpy as np
import polars as pl
fig, ax = plt.subplots(figsize=[4, 5])

ax.plot(x[0])
samp_ids = np.random.randint(size=25, low=0, high=999)
for samp_id in samp_ids:
    sub_samps = samps.filter(pl.col("draw") == samp_id).sort(pl.col('time'))
    ax.plot(sub_samps.select("time").to_numpy(),
            sub_samps.select("Rt").to_numpy(), color="darkblue", alpha=0.1)
ax.set_ylim([0.4, 1/.4])
ax.set_yticks([0.5, 1, 2])
ax.set_yscale("log")

# Can we use ArviZ for visualization? It is included in poetry dependencies.
```
