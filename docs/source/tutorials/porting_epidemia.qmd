---
title: "Porting Over `cfaepim` To MSR"
description: "_MSR is designed to be able to re-implemented existing infectious disease models. In this tutorial, we instantiate, in MSR, an influenza forecasting model originally created using_ Epidemia."
title-block-banner: "black"
image: "porting-cfaepim-to-msr.png"
date: "2024-06-15"
date-modified: "2024-07-23"
bibliography: references.bib
link-citations: true
csl: "./assets/csls/vodohospodarske-technicko-ekonomicke-informace-en_MODIFIED.csl"
categories: ["epidemiology", "modelling", "python", "R", "tutorial"]
margin-header: |
  ![](porting-cfaepim-to-msr.png)
downloads: [pdf]
format:
  html:
    fig-width: 8
    fig-height: 6
---


<!-- pdf:
    toc: true
    toc-depth: 3
    number-sections: true
    colorlinks: true
    fontsize: 12pt
    papersize: letter
    mainfont: TeX Gyre Schola
    geometry:
      - lmargin=1.5in
      - rmargin=1.5in
      - tmargin=1.0in
      - bmargin=1.0in
    cite-method: citeproc
    include-in-header:
      - text: |
          \usepackage{xcolor}
          \usepackage{fontspec}
          \usepackage{amssymb}
          \usepackage{amsmath}
          \usepackage{sectsty}
          \allsectionsfont{\scshape}
          \usepackage{fancyvrb}
          \fvset{fontsize=\small, frame=single,framesep=2mm,rulecolor=\color{black}, framerule=0.4mm}
          \usepackage{float}
          \let\origfigure\figure
          \let\endorigfigure\endfigure
          \renewenvironment{figure}[1][H]{\origfigure[H]}{\endorigfigure}
          \usepackage{mathrsfs}
          \usepackage{fvextra} -->

# [Introduction](#introduction)

Let's[^we] remind ourselves of the Multisignal Renewal (hereafter MSR[^msr_v_pyrenew]) project's core utilities:

[^we]: This tutorial switches between first person plural narrative tense and third person narrative tense. When explaining mathematical details or when manipulating or building code, the author prefers the former tense, imagining himself alongside the reader on a path of discovery. All other presentation adopts the more dispassionate latter tense out of formality.

[^msr_v_pyrenew]: The author of this tutorial prefers the use of _MSR_ to `pyrenew`, despite `pyrenew` being the name of the package associated with the MSR project, since the author believes "Multisignal Renewal" conveys relatively more information about the purpose of the project. Also note that the described utilities are current as of 2024-07-28 and come from MSR's [website home page](https://cdcgov.github.io/multisignal-epi-inference/).

> * ...a Python library that provides a flexible renewal modeling framework
> * ...a pipeline that leverages this framework to estimate epidemiological parameters from multiple data sources and produce forecasts.

With these goals—particularly that of _flexibility_ in renewal modeling—fresh in the reader's mind, one action the reader (as an MSR user) might want to take is to re-implement external (as in not pre-packaged) infectious disease models via MSR.

Such an action might help the reader to better understand how [statistical inference](https://en.wikipedia.org/wiki/Statistical_inference) and [simulation](https://en.wikipedia.org/wiki/Simulation) work in MSR and to validate (using the MSR-implemented external model) that the MSR codebase works as intended.

This tutorial constitutes the first re-implementation of an external renewal model. In particular, the author demonstrates in this tutorial how to implement, via MSR, an influenza forecasting model (hereafter `cfaepim`[^cfaepim]) that was created using the [Epidemia](https://imperialcollegelondon.github.io/epidemia/index.html) framework.

[^cfaepim]: The `cfaepim` model is in a private [CDC Enterprise](https://github.com/cdcent) repository, so the full `cfaepim` code is not available to the public. However, the author of this tutorial has received permission from [the author](https://github.com/dylanhmorris) of `cfaepim` to reproduce the parts of the model code (in particular, `model.R`, `forecast.R`, and `fit.R`).

__Tutorial Overview__:

1. The author begins by outlining some background information that is either helpful or required for the completion of this tutorial.
2. Next, the author showcases some historical influenza hospitalization data for the United States and a `cfaepim` forecast made using this data.
3. Next, the author demonstrates how to implement `cfaepim` via MSR.
4. Finally, the author compares forecasts made between `cfaepim` and MSR-`cfaepim`. This comparison coincides with the author's reflections on future MSR work needed, in both a general manner and also one pertaining to MSR-`cfaepim` in particular.

<!-- This demonstration coincides with a mathematical outline of `cfaepim`. -->

# [Background](#background)

## [MSR](#msr)

_How to install MSR and what to know before installing._

For the reader's edification, the author recommends proceeding through the following tutorials before this tutorial (the arrows indicate the recommended order of tutorials, but this order does not _need_ to be followed): [Getting started with `pyrenew`](https://cdcgov.github.io/multisignal-epi-inference/tutorials/getting_started.html) &rarr; [Fitting a basic renewal model](https://cdcgov.github.io/multisignal-epi-inference/tutorials/basic_renewal_model.html) &rarr; [Fitting a hospital admissions-only model](https://cdcgov.github.io/multisignal-epi-inference/tutorials/hospital_admissions_model.html).

The following prerequisites and installation help come from the following [tutorial](https://cdcgov.github.io/multisignal-epi-inference/tutorials/getting_started.html) but are worth reproducing here:

> ### Prerequisites
>
> This tutorial assumes some pre-existing knowledge of infectious disease dynamics and Python programming. Before you dive in, we recommend:
>
> -   Installing Python3 (use tools like [pyenv](https://realpython.com/intro-to-pyenv/) or [compile and install](https://ubuntuhandbook.org/index.php/2023/05/install-python-3-12-ubuntu/) from the [release page](https://www.python.org/downloads/))
-   Familiarity with installing and loading modules in python, and with virtual environment management (we recommend [poetry](https://python-poetry.org/docs/))
-   Familiarity with the concept of a [class](https://realpython.com/python-classes/) and [metaclass](https://realpython.com/courses/python-metaclasses/) in python
-   Familiarity with Bayesian inference, and a working understanding of MCMC methods used to fit Bayesian models to data (some resources are available [here](https://mc-stan.org/docs/2_18/reference-manual/effective-sample-size-section.html), and [here](https://xcelab.net/rm/))
>
> ### Installing pyrenew
>
> You’ll need to install pyrenew using either poetry or pip. To install pyrenew using poetry, run the following command from within the directory containing the pyrenew project:
>
> ```poetry install```
>
> To install pyrenew using pip, run the following command:
>
>
```pip3 install git+https://github.com/CDCgov/multisignal-epi-inference@main#subdirectory=model```

## [Renewal Modeling](#renewal-modeling)

_A brief historical and epidemiological coverage of the renewal equation._

A comprehensive introduction to renewal modeling has little place in this tutorial, for the sake of time (of both the reader and the author) and as there are already such introductions elsewhere; however, the following references might well stoke readers' remembrance of the renewal equation and its use in infectious disease modeling.

Also, regarding background familiarities, if the terms _generation interval_ or _basic reproduction number_ or _effective reproduction number_ are fuzzy concepts to the reader, then the author suggests taking a step back from this tutorial and referencing some of the resources found in the [Appendix](#appendix).

__Renewal Equation__ (Historical) [@champredon2018equivalence, pp.3258-3267]

> The renewal equation was introduced by Euler in 1767 [@euler1767recherches] in his work on population dynamics and was reframed in a modern continuous formulation by Lotka in 1907 [@lotka1907relation]. Lotka's formulation is usually expressed as $$B(t) = \int^{\infty}_0 B(t-a) p(a) \nu(a) da$$ where $B(t)$ is the number of births at time $t$, $p(a)$ is the probability of survival to age $a$, and $\nu(a)$ is the fertility at age $a$. This equation was derived for demographic studies and has been adapted to epidemics using an "age of infection" model that was described in the seminal work of Kermack and McKendrick in 1927 [@kermack1927contribution]. This epidemic model changes the interpretation of the variables: $B(t)$ represents the number of new infectious individuals at time $t$, $p(a)$ the probability to be infectious a time units after acquiring the disease, and $\nu(a)$ the "transmission potential" that is, the average number of secondary infections at "infection age" $a$.

<!--
TODO:

Explore the equations under discretization with different values for the parameters

Let us take a moment to explore the above equation from Lotka's but not Kermack and McKendrick's perspective. We can imagine several scenarios, -->

__Renewal Equation__ (Epidemiology) [@pakkanen2023unifying, pp.35]

> The form of this renewal equation when only considering $\mathscr{R}_0$ is exactly what is commonly used in epidemic modelling where the incidence of infections $I(t)$ follows a renewal equation given by $$I(t) = \mathscr{R}_0 \int_0^{\infty} I(t-u)g(u)du$$ where $g(\cdot)$ is the probability density function (PDF) of the generation interval. Introducing a time-varying reproduction number $\mathscr{R}(t)$ within the Bellman–Harris process in general does not simply entail replacing $\mathscr{R}_0$ with $\mathscr{R}(t)$ in the renewal equation.

## [Epidemia](#epidemia)

_A brief introduction to Epidemia._

These resources constitute the bulk of the [Epidemia](https://imperialcollegelondon.github.io/epidemia/index.html) content relevant to this tutorial:

* [Epidemia Model Description Page](https://imperialcollegelondon.github.io/epidemia/articles/model-description.html)
* [Epidemia Model Schematic Page](https://imperialcollegelondon.github.io/epidemia/articles/model-schematic.html)
* [Epidemia Model Implementation Page](https://imperialcollegelondon.github.io/epidemia/articles/model-implementation.html)

The Model Description Page includes references to the papers on which Epidemia is based. Rather than attempt to re-describe the general ethos of Epidemia and the class of problems it aims to help its users solve, the author reproduces these descriptions from Epedmia.

On Epidemia...

> The open-source R (R Core Team [2020](https://imperialcollegelondon.github.io/epidemia/articles/model-introduction.html#ref-rcore_2011)) package **epidemia** provides a framework for Bayesian, regression-oriented modeling of the temporal dynamics of infectious diseases. Typically, but not exclusively, these models are fit to areal time-series; i.e. aggregated event counts for a given population and period. Disease dynamics are described explicitly; observed data are linked to latent infections, which are in turn modeled as a self-exciting process tempered by time-varying reproduction numbers. Regression models are specified for several objects in the model. For example, reproduction numbers are expressed as a transformed predictor, which may include both covariates and autoregressive terms. A range of prior distributions can be specified for unknown parameters by leveraging the functionality of **rstanarm** (Goodrich et al. [2020](https://imperialcollegelondon.github.io/epidemia/articles/model-introduction.html#ref-goodrich_2020)). Multilevel models are supported by partially pooling covariate effects appearing in the predictor for reproduction numbers between multiple populations.

On the class of problems Epidemia is aimed at addressing...

> We now formulate the basic version of the model for one homogeneous population. The same model can be used for multiple regions or groups jointly. Suppose we observe a non-negative time series of count data $Y=(Y_1,\dotsc,Y_n)$ for a single population. This could for example be daily death or case incidence. $Y_t$ is modeled as deriving from past new infections is, $s<t$, and some parameter $\alpha_t > 0$, a multiplier, which in most contexts represents an instantaneous ascertainment rate. The general model can be expressed as deriving from past new infections $i_s$, $s<t$, and some parameter $\alpha_t>0$, a multiplier, which in most contexts represents an instantaneous _ascertainment rate_. The general model can be expressed as $$Y_t \sim p(y_t, \phi)$$ $$y_t = \alpha_t \sum_{s<t}i_s \pi_{t-s}$$ where $y_t$ is the expected value of the data distribution and $\phi$ is an auxiliary parameter. $\pi_k$ is typically the time distribution from an infection to an observation, which we refer to as the infection to observation distribution. More generally, however, $\pi_k$ can be used to obtain any linear combination of past infections. New infections $i_t$ at times $t>0$ are modeled through a renewal equation, and are tempered by a non-negative parameter $\mathscr{R}_t$ which represents the reproduction number at time $t$. Formally $$i_t = \mathscr{R}_t \sum_{s<t}i_s g_{t-s}$$ where $g_k$ is a probability mass function for the time between infections. The recursion is initialized with seeded infections $i_{v:0}, v<0$, which are treated as unknown parameters. All parameters are assigned priors, i.e. $$i_{v:0},\mathscr{R},\phi,\alpha \sim p(\cdot)$$ where $\mathscr{R} = (\mathscr{R}_1,\dotsc,\mathscr{R}_n)$ and $\alpha=(\alpha_1,\dotsc,\alpha_n)$. The posterior distribution is then proportional to prior and likelihood, i.e.  $$p(i_{v:0},\mathscr{R},\phi,\alpha∣Y)\propto p(i_{v:0})p(\mathscr{R})p(\phi)p(\alpha)\prod_t p(Y_t∣y_t,\phi)$$.

## [`cfaepim`](#cfaepim)

_An introduction to `cfaepim`._

In addition to daily death or case incidence, Epidemia can be made to support count data for reported influenza hospitalizations from individual jurisdictions—this data stream, for the United States, is exactly what `cfaepim` is build to model.

The `cfaepim` model is written in `R` and consists of pre- and post-processing functions that interface with an Epidemia-instantiated model.

The calls to Epidemia made in `cfaepim` are spread across three sections: (1) a transmission component, (2) an observation component, and (3) an infections component. In component (3), the earlier transmission and observation components are called and incorporated. See

Since Epidemia affords users a variety of modeling approachings, such as treating infections as parameters or incorporating susceptible depletion, many different models can be built. The explanation and subsequent mathematics below describe what variety of Epidemia model `cfaepim` became.

### [Model Description](#model-description)

Denote[^note_on_descr] $P \in \mathbb{N}$ the population of some US territory. Denote influenza hospitalizations in this terrority over an interval of time $Y = (Y_1, \dotsc, Y_n), \quad Y_t \in \mathbb{N}, \quad t \in \{1, \dotsc, n\}$.

Let the hospitalizations at time $Y_t$ be drawn from negative binomial distribution with $y_t$ as the mean and $\phi \sim \mathcal{N}(10, 5)$ as the dispersion, i.e. $Y_t \sim \text{NB}(y_t, \phi)$.

The expected number of influenza hospitalizations at time $t$, $y_t = \alpha_t \sum_{s<t}i_s' \pi_{t-s}$, is the weighted sum of past infections at times $s < t$, where the weights are given by a delay distribution (Epidemia calls this the _infection to observation distribution_), scaled by the ascertainment rate $\alpha_t > 0$ (i.e. the rate at which influenza infections become reported hospitalizations) for that point in time.

Further, the instananeous ascertainment rate at time $t$, $\alpha_t = h^{-1}_1(\eta_{1,t})$, is a scaled-logit transformed linear predictor.

The scaled-logit is given by $h^{-1}_1(x) = \frac{1}{1 + e^{-x}}, \quad h^{-1}_1: \mathbb{R} \to (0,1)$.

The linear predictor, $\eta_{1,t} = \beta_{1,0} + \sum_{i=1}^9 \beta_{1,i} x_i$, at time $t$ consists of several effects and intercept $\beta_{1,0} \sim \mathcal{N}(-6.5, 0.5)$. In particular, there is an effect for each day of the week (where the reference day is Thursday, indexed 4) with coffecients $\beta_{1,1}, \dotsc, \beta_{1,6} \sim \mathcal{N}(0, 0.25)$, an effect for days that are holidays with coffecient  $\beta_{1,7} \sim \mathcal{N}(-0.2, 0.2)$, an effect for days that occur after a holiday with coffecient $\beta_{1,8} \sim \mathcal{N}(0, 0.2)$, and an effect for days occurring before observations with coefficient $\beta_{1,9} \sim \mathcal{N}(-50, 0.01)$.

Altogether, then, we have:

$$\alpha_t = h^{-1}_1(\eta_{1,t}) = \frac{1}{1 + e^{-\eta_{1,t}}} =  \frac{1}{1 + e^{-\big(\beta_{1,0} + \sum_{i=1}^9 \beta_{1,i} x_i\big)}}$$

New infections at time $t$, $i_t = \mathscr{R}_t \sum_{s < t} i_s g_{t-s}$, are a weighted sum of past infections at times $s < t$, where the weights are given by $g$, _a probability mass function for the time between infections_, that is scaled by the rate at that point in time at which new infections arise from existing infections, i.e. the reproduction number at time $t$, $\mathscr{R}_t$.


NOTE: The remaining stands to be done. (1) Describe the depletion of susceptibles. (2) Describe the seeding. (3) Describe the calculations for $\mathscr{R}_t$. As for (3), this has already been somewhat completed in the PR.


<!-- these come from a susceptible population $S_t \in [0, P]$.

The delay distribution is given by:

$$\pi = \begin{bmatrix} 0.05 & 0.1 &  0.175 & 0.225 &  0.175 &  0.125 & 0.075 &  0.05 & 0.025\end{bmatrix}$$
 -->


__Terms From The Explanation__

$$
\begin{aligned}
& P \in \mathbb{N} \\
& Y = (Y_1, \dotsc, Y_n), \quad Y_t \in \mathbb{N}, \quad t \in \{1, \dotsc, n\} \\
& Y_t \sim \text{NB}(y_t, \phi) \\
& \phi \sim \mathcal{N}(10, 5) \\
& y_t = \alpha_t \sum_{s<t}i_s' \pi_{t-s} \\
& \alpha_t = h^{-1}_1(\eta_{1,t}) \\
& h^{-1}_1(x) = \frac{1}{1 + e^{-x}}, \quad h^{-1}_1: \mathbb{R} \to (0,1)  \\
& \eta_{1,t} = \beta_{1,0} + \sum_{i=1}^9 \beta_{1,i} x_i \\
& \beta_{1,0} \sim \mathcal{N}(-6.5, 0.5) \\
& \beta_{1,1}, \dotsc, \beta_{1,6} \sim \mathcal{N}(0, 0.25) \\
& \beta_{1,7} \sim \mathcal{N}(-0.2, 0.2) \\
& \beta_{1,8} \sim \mathcal{N}(0, 0.2) \\
& \beta_{1,9} \sim \mathcal{N}(-50, 0.01)\\
& \pi = \begin{bmatrix} 0.05 & 0.1 &  0.175 & 0.225 &  0.175 &\\  0.125 & 0.075 &  0.05 & 0.025\end{bmatrix} \\
& i_t' = \mathscr{R}_t \sum_{s < t} i_s g_{t-s} \\
& g = \begin{bmatrix} 0.233 & 0.359 & 0.198 & 0.103 & 0.053 &\\ 0.027 & 0.014 & 0.007 & 0.003 & 0.002 & 0.001\end{bmatrix}\\
& i_k = i, \quad k \in \{v, \dotsc, 0\}, \quad v = -8 \\
& i \sim \text{Exp}(\tau^{-1}) \\
& \tau \sim \text{Exp}(\lambda_0), \quad \lambda_0 \in (0, \infty) \\
& S_t \in [0, P] \\
& i_t = S_{t-1} \bigg(1 - \exp\bigg(-\frac{i_t'}{P}\bigg) \bigg) \\
& S_t = S_{t-1} - i_t \\
& \frac{S_{v-1}}{P} \sim \mathcal{N}(0.9, 0.1) \\
& \mathscr{R}_t = h^{-1}_2(\eta_{2,t}) \\
& h^{-1}_2(x) = \frac{K}{1 + e^{-x}}, \quad h^{-1}_2: \mathbb{R} \to (0, K), \quad K = 3\\
& \eta_{2,t} = \beta_{2,0} + W_t \\
& \beta_{2,0} \sim \mathcal{N}(-0.4054651, 0.3) \\
& W_t = W_{t-1} + \gamma_t, \quad W_0 = 0\\
& \gamma_t \sim \mathcal{N}(0, \sigma) \\
& \sigma \sim \mathcal{N}^{+}(0, 0.25) \\
& p(i_{v:0},\mathscr{R},\phi,\alpha∣Y) \propto p(i_{v:0})p(\mathscr{R})p(\phi)p(\alpha)\prod_t p(Y_t∣y_t,\phi)
\end{aligned}
$$

[^note_on_descr]: This description can be reproduced for each US territory. I decided, for clarity, to not index variables here by territory, e.g. if Alabama is territory $1$, then $Y_t^{(1)}$ would be the influenza hospitalizations at time $t$ for territory $1$.


### [Transmission Component](#transmission)

In `cfaepim`, the influenza hospitalizations for each US territory are modelled separately, as though each territory's influenza dynamics are completely unique, i.e. independent of the influenza dynamics in other territories. This corresponds to an "unpooled" modelling case (see [Epidemia's partial pooling page](https://imperialcollegelondon.github.io/epidemia/articles/partial-pooling.html)). For each US territory, the effective reproduction number at time $t$, $\mathscr{R}_t$, can be modeled as a transformed linear prediction:

<!-- (the transmission of influenza, influenza infection, and the observation of influenza hospital admissions -->

$$\mathscr{R}_t = g^{-1}(\eta_t)$$

where $g$ is a link function and $\eta_t$ is the prediction on the transformed scale.

The link function for `cfaepim` is a scaled logit, so:

$$g^{-1}(x) = \frac{K}{1 + e^{-x}}$$

with $K = 3$ since `max_rt = 3.0`. As for each territory's transformed scale prediction $\eta_t$, we have

$$\eta_t = \beta_0 + W_t$$

where $W_t$ is a random walk satisfying $$W_t = W_{t-1} + \gamma_t$$ with $t > 0$ and $W_0 = 0$, and $\gamma_t \sim \mathcal{N}(0, \sigma)$, where $\sigma \sim \mathcal{N}^{+}(0, 0.25)$ since `weekly_rw_prior_scale = 0.25`. Note that the $\mathscr{R}_t$ intercept, i.e. $\beta_0$, has a prior. Since `rt_intercept_prior_mode = -0.4054651` and  `rt_intercept_prior_scale = 0.3`, $\beta_0 \sim \mathcal{N}(-0.4054651, 0.3)$.


### [Observation Component](#observation)

Proceeding, each US territory has is own time series of observed influenza hospitalizations $Y = (Y_1, \dotsc, Y_n)$. The observed influenza hospitalizations at time $t$ are given by $$Y_t \sim \mathcal{D}(y_t, \phi)$$ where $\mathcal{D}(y_t, \phi)$ is the sampling distribution with auxiliary parameter $\phi$.

This distribution is not fixed; rather, it is determined by the `family` variable in Epidemia's `epiobs` function.

Since `family = "neg_binom"` in `cfaepim`, $\mathcal{D}(y_t, \phi)$ is the [negative binomial distribution](https://en.wikipedia.org/wiki/Negative_binomial_distribution) parameterized by its mean and reciprocal dispersion ($\phi$).

Note that since `reciprocal_dispersion_prior_mode = 10` and `reciprocal_dispersion_prior_scale = 5`, we have the prior $\phi \sim \mathcal{N}(10, 5)$.

The expected value for the observed influenza hospitalizations on day $t$, i.e. $y_t$, is given by $$y_t = \alpha_t \sum_{s<t}i_s \pi_{t-s}$$ with $s < t$ and where

* $\pi_{k}$ is the _time distribution from an infection to an observation_
* $i_s$ are new infections as modelled via a renewal equation
* $\alpha_t>0$ _represents an instantaneous ascertainment rate_, which in this instance means the rate of influenza infections that become reported hospitalizations at time $t$, modeled by a linear model with a logit link (since `link = "logit"`), i.e. the function $g$, where $$g^{-1}(x) = \frac{1}{1 + e^{-x}}$$

Within `cfaepim`, the linear predictor for $\alpha_t$ consists of

* A "_day of the week effect on observation probability, relative to the reference day of the week_" (`day_of_week`).
* A holiday effect, if the day is a holiday (`is_holiday`).
* A post-holiday effect, if the day occurs after a holiday (`is_post_holiday`).

We have:

$$
\begin{aligned}
\alpha_t &= g^{-1}(\eta_t)\\
\eta_t &= \beta_0 + \sum_{i=1}^9 \beta_i x_i
\end{aligned}
$$

where

* the infection to hospitalization delay distribution intercept $\beta_0 \sim \mathcal{N}(-6.5, 0.5)$, since `ihr_intercept_prior_mode = -6.5` and `ihr_intercept_prior_scale = 0.5` .
* each of the coefficients $\beta_1, \dotsc, \beta_6$ have priors, $\beta_i \sim \mathcal{N}(0, 0.25) \quad i = 1, \dotsc, 6$ (see `day_of_week_effect_prior_modes` and `day_of_week_effect_prior_scales`) with `reference_day_of_week = 4`, i.e. Thursday, since epiweeks index Sunday at 0.
* the coefficient $\beta_7 \sim \mathcal{N}(-0.2, 0.2)$, since `holiday_eff_prior_mode = -0.2` and `holiday_eff_prior_scale = 0.2`, and refers to the holiday effect.
* the coefficient $\beta_8 \sim \mathcal{N}(0, 0.2)$, since `post_holiday_eff_prior_mode = 0.0` and `post_holiday_eff_prior_scale = 0.2`, and refers to the post-holiday effect.
* the coefficient $\beta_9 \sim \mathcal{N}(-50, 0.01)$, since `non_obs_effect_prior_mode = -50` and `non_obs_effect_prior_scale = 0.01`, and refers to the _change in the observation probability during the nonobservation (seeding) period_.

Within `cfaepim`, we have the infection to hospitalization delay distribution as $$\pi = \begin{bmatrix} 0.05 & 0.1 &  0.175 & 0.225 &  0.175 &  0.125 & 0.075 &  0.05 & 0.025\end{bmatrix}$$ given the selected value for `inf_to_hosp_dist`.

## [Dataset](#dataset)

The `cfaepim` repository was employed during the 2023-24 respiratory season to forecast weekly influenza hospitalizations in US territories.

As for the influenza dynamics of each US state, `cfaepim` treats these dynamics as being unique to the state; this is typically termed the "unpooled" approach, which is the same as assuming that information on influenza dynamics in other states will not provide any guidance on the influenza dynamics in the current state. While `cfaepim` constitutes an "unpooled" approach, Epidemia does allow for [partial pooling](https://imperialcollegelondon.github.io/epidemia/articles/partial-pooling.html).

The influenza hospital admissions data `cfaepim` uses was released by the Center For Disease Control and Prevention (CDC) (see [heathdata.gov](https://healthdata.gov/Hospital/COVID-19-Reported-Patient-Impact-and-Hospital-Capa/g62h-syeh)). This data is commonly referred to as the "NHSN" (the National Healthcare Safety Network) dataset[^flusight].

While not all columns[^columns] are represented here, the slightly modified version of the data, incorporating US Census 2020 population figures for each state, looks like:

[^columns]: The column names of the dataset employed in `cfaepim` are ['location', 'date', 'hosp', 'epiweek', 'epiyear', 'day_of_week', 'is_weekend', 'is_holiday', 'is_post_holiday', 'recency', 'week', 'location_code', 'population', 'first_week_hosp']

| location | date       | hosp | … | location_code | population | first_week_hosp |
|----------|------------|------|---|---------------|------------|-----------------|
| AK       | 2023-09-15 | 0    | … | 02            | 732673     | 2               |
| AK       | 2023-09-16 | 2    | … | 02            | 732673     | 2               |
| AK       | 2023-09-17 | 0    | … | 02            | 732673     | 2               |
| AK       | 2023-09-18 | 0    | … | 02            | 732673     | 2               |
| AK       | 2023-09-19 | 1    | … | 02            | 732673     | 2               |
| AK       | 2023-09-20 | 2    | … | 02            | 732673     | 2               |
| AK       | 2023-09-21 | 1    | … | 02            | 732673     | 2               |
| AK       | 2023-09-22 | 1    | … | 02            | 732673     | 2               |
| …        | …          | …    | … | …             | …          | …               |
| WY       | 2024-01-07 | 8    | … | 56            | 578803     | 0               |
| WY       | 2024-01-08 | 3    | … | 56            | 578803     | 0               |
| WY       | 2024-01-09 | 4    | … | 56            | 578803     | 0               |
| WY       | 2024-01-10 | 10   | … | 56            | 578803     | 0               |
| WY       | 2024-01-11 | 14   | … | 56            | 578803     | 0               |
| WY       | 2024-01-12 | 10   | … | 56            | 578803     | 0               |
| WY       | 2024-01-13 | 7    | … | 56            | 578803     | 0               |

For some weeks during the respiratory season, some territories (e.g., Kansas) experienced major reporting delays and errors. To handle such reporting anomalies, `cfaepim` users are able to select data start and cutoff intervals, in addition to data exclusion intervals, for particular territories and epiweeks.

[^flusight]: To see forecasts from influenza models using this data, see [here](https://github.com/cdcepi/FluSight-forecasts). For more information regarding how this data has been used for influenza forecasting, see [here](https://github.com/cdcepi/FluSight-forecast-hub/tree/main/target-data).

The following is influenza hospital admissions for New York state from the NHSN dataset over the last few years:

![New York state influenza hospitalizations.](./figures/NY_2022-01-01-2024-03-10.png){ width=75% }

The following are some `cfaepim` forecasts for NY during the 2023-24 season:

![The 4 week projected influenza hospitalizations (quantilized) for target epiweek 2024-03-30. The `cfaepim` forecast was made excluding the epiweek ending on 2024-03-20; this exclusion was reported in the epiweek's `output` folder.](./figures/NY_cfaepim_2024-03-30_snapshot.png){ width=75% }

![Historical influenza hospitalizations for NY preceding the target epiweek 2024-03-30, along with a quantilized `cfaepim` forecast.](./figures/NY_cfaepim_2024-03-30_historical.png){ width=75% }

For each forecasting week in the 2023-24 respiratory season, the author of `cfaepim` stored the NHSN data as it stood prior to making forecasts. For this reason, the least biased method of comparing `cfaepim` and MSR-`cfaepim` forecasts is by week.

# [MSR-Porting Of `cfaepim`](#msr-port-cfaepim)

__Section Overview__:

1. The author begins by outlining the `cfaepim` configuration file.
2. Next, the author details the imports required for the re-implementation.
3. Finally, the author builds the components of MSR-`cfaepim` one component at a time, while explaining the MSR design principles that inform the decision-making in the re-implementation.

## [Configuration File](#configuration)

The following variables and their values (which the author has stored in a file called `params.toml`) come from the specification of `cfaepim` in the [Model Description](#model-description).

Skimming these values now might prove useful, but knowing them in detail is not necessary. The author of this tutorial cannot currently justify the values of these variables, but is in the process of obtaining justifications.

```yaml
day_of_week_effect_prior_modes = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
day_of_week_effect_prior_scales = [0.25, 0.25, 0.25, 0.25, 0.25, 0.25]
holiday_eff_prior_mode = -0.2
holiday_eff_prior_scale = 0.2
post_holiday_eff_prior_mode = 0.0
post_holiday_eff_prior_scale = 0.2
recency_eff_prior_mode = 0.0
recency_eff_prior_scale = 0.1
recency_effect_length = 0

generation_time_dist = [0.233, 0.359, 0.198, 0.103, 0.053, 0.027, 0.014, 0.007, 0.003, 0.002, 0.001]
ihr_intercept_prior_mode = -6.5
ihr_intercept_prior_scale = 0.5
inf_model_prior_infections_per_capita = 0.0001
inf_model_seeds = 8
inf_to_hosp_dist = [0.05, 0.1, 0.175, 0.225, 0.175, 0.125, 0.075, 0.05, 0.025]
max_rt = 3.0
n_pre_observation_days = 14
non_obs_effect_prior_mode = -50
non_obs_effect_prior_scale = 0.01
reciprocal_dispersion_prior_mode = 10
reciprocal_dispersion_prior_scale = 5
reference_day_of_week = 4
rt_intercept_prior_mode = -0.4054651
rt_intercept_prior_scale = 0.3
seed = 54321
susceptible_fraction_prior_mode = 0.9
susceptible_fraction_prior_scale = 0.1
weekly_rw_prior_scale = 0.25
first_fitting_date = "2023-09-15"

[location_specific_start_dates]

[location_specific_cutoff_dates]

[location_specific_excluded_dates]
KS = ["2024-01-30", "2024-01-31",
      "2024-02-01", "2024-02-02",
      "2024-02-03", "2024-02-04",
      "2024-02-05", "2024-02-06",
      "2024-02-07", "2024-02-08",
      "2024-02-09", "2024-02-10",
      "2024-02-11", "2024-02-12",
      "2024-02-13", "2024-02-14",
      "2024-02-15", "2024-02-16",
      "2024-02-17"]
AZ = ["2024-03-04", "2024-03-09",
      "2024-03-11", "2024-03-16"]
GA = ["2024-03-11", "2024-03-12",
      "2024-03-22", "2024-03-23"]
HI = ["2024-01-30", "2024-01-31",
      "2024-02-01"]
IL = ["2024-03-17", "2024-03-18"]
IA = ["2024-03-23"]
KY = ["2024-03-01", "2024-03-14"]
MO = ["2024-03-10"]
NV = ["2024-02-23", "2024-02-26"]
NH = ["2024-03-21", "2024-03-22",
      "2024-03-23"]
NY = ["2024-03-20"]
NC = ["2024-03-14", "2024-03-15"]
OK = ["2024-03-19"]
RI = ["2024-02-18", "2024-02-19",
      "2024-02-20", "2024-02-21",
      "2024-02-26"]
SD = ["2024-03-21"]
TN = ["2024-03-16"]
TX = ["2024-03-21"]
WA = ["2024-03-08", "2024-03-12"]
WI = ["2024-02-05"]
WV = ["2024-03-03"]

[mcmc]
adapt_delta = 0.9
max_treedepth = 12
n_chains = 1
n_warmup = 1000
n_iter = 2000

[postprocess]
exclude = ["HI"]
```

Since for each week `cfaepim` used a different snapshot of NHSN data for forecasting, each week also had its own configuration file in `cfaepim`. The above configuration file is for the week ending on 2024-03-30, for example.

Each configuration file contains different data inclusions and exclusions based on new anomalies following weekly updates to the NHSN dataset.

For each week on which `cfaepim` has forecasted, the author of this tutorial adopts the appropriate configuration file.

<!-- modify this writing somewhat -->

However, for the sake of brevity in this tutorial, the author separates the fundamental model categories (all variables except for those in `[location_specific_start_dates]`, `[location_specific_cutoff_dates]`, `[location_specific_excluded_dates]`, `[postprocess]`) into there own configuration file called `params_<week>.toml`.

## [Libraries](#libraries)

Let us begin with the appropriate libraries. How this libraries are utilized will soon become apparent.

```python
# | label: setup
import datetime as dt
import os

import jax
import jax.numpy as jnp
import matplotlib.dates as mdates
import matplotlib.pyplot as plt
import numpy as np
import numpyro as npro
import numpyro.distributions as dist
import numpyro.distributions.transforms as transforms
import polars as pl
import pyrenew.transformation as t
import toml
from matplotlib import font_manager as fm
from pyrenew.deterministic import DeterministicPMF
from pyrenew.latent import (
    HospitalAdmissions,
    InfectionInitializationProcess,
    Infections,
    InitializeInfectionsZeroPad,
)
from pyrenew import model, process, observation, metaclass, transformation
from pyrenew.metaclass import DistributionalRV, Model
from pyrenew.model import HospitalAdmissionsModel
from pyrenew.observation import NegativeBinomialObservation
from pyrenew.process import RtRandomWalkProcess
```

## [Data & Configuration Loading](#data-config-load)












# [Appendix](#appendix)

## [Available `cfaepim` Code](#available)

### [`model.R`](#modelR)

```R
#' Augment a set of epidemia data with a
#' preobservation period
#'
#' This allows for more robust initialization
#' of the renewal process.
#'
#' @param data The data to augment
#' @param n_pre_observation_days number of
#' pre-observation days with which to augment it.
#' @return the augmented data frame, as a [tibble::tibble()]
#' @export
add_pre_observation_period <- function(data,
                                       n_pre_observation_days) {
  pre_observation_data <- tibble::tibble(
    date = min(data$date) - n_pre_observation_days:1,
    hosp = NA,
    nonobservation_period = TRUE,
    location = data$location[1],
    population = data$population[1],
    day_of_week = factor(
      lubridate::wday(date,
        label = TRUE
      ),
      ordered = FALSE,
      levels = levels(data$day_of_week)
    ),
    is_holiday = FALSE,
    is_post_holiday = FALSE,
    recency = 0,
    week = data$week[1] ## this prevents RW during seeding
  )

  aug_data <- pre_observation_data |>
    dplyr::bind_rows(data) |>
    dplyr::mutate(hosp = ifelse(nonobservation_period,
      0,
      hosp
    ))
  print(aug_data |> tail())
  return(aug_data)
}

#' Build the R(t) component of a "covariate
#' light" epidemia model.
#'
#' @param rt_intercept_prior_mode prior mode
#' for R(t) intercept. Prior is Normal on the
#' transformed (scaled logit) scale.
#' @param rt_intercept_prior_scale prior standard
#' deviation (scale) for R(t) intercept. Prior is
#' Normal on the transformed (scaled logit) scale.
#' @param max_rt Maximum permitted R(t) value (upper
#' limit of the scaled logit), on the natural scale.
#' R(t) will be permitted to range between 0 and
#' this value.
#' @param rw_prior_scale prior standard deviation
#' (scale parameter) for the random walk on R(t).
#' Random walk steps are Normal on the transformed
#' (scaled logit) scale.
#' @return the R(t) model, as the output
#' of an [epidemia::epirt()] call.
#' @export
build_light_rt <- function(rt_intercept_prior_mode,
                           rt_intercept_prior_scale,
                           max_rt,
                           rw_prior_scale) {
  rt_model <- epidemia::epirt(
    formula = as.formula(
      sprintf(
        paste0(
          "R(location, date) ~ 1 + ",
          "rw(time = week, gr = location, prior_scale = %f)"
        ),
        rw_prior_scale
      )
    ),
    prior_intercept = rstanarm::normal(
      location = rt_intercept_prior_mode,
      scale = rt_intercept_prior_scale
    ),
    link = epidemia::scaled_logit(K = max_rt)
  )

  return(rt_model)
}

#' Build the observation component of a "covariate
#' light" epidemia model.
#'
#' @param inf_to_hosp_dist infection to hospitalization
#' delay distribution, passed as the `i2o` parameter
#' to [epidemia::epiobs()].
#' @param ihr_intercept_prior_mode Normal prior mode for
#' the overall infection (observed) hospitalization rate
#' (i.e. the probability that an arbitrary infected individual
#' gets observed admitted to the hospital), before taking
#' into account any covariates.
#' Specified on the transformed scale (see `link` parameter).
#' @param ihr_intercept_prior_scale Normal prior scale for the
#' intercept of the regression predicting the
#' infection (observed) hospitalization rate
#' (i.e. the probability that an arbitrary infected individual
#' gets observed admitted to the hospital), before taking
#' into account any covariates.
#' Specified on the transformed scale (see `link` parameter).
#' @param day_of_week_eff_prior_modes Normal prior
#' modes for the day of the week effect on observation
#' probability, relative to the reference day of the week.
#' Should be a vector of length 6.
#' Specified on the transformed scale (see `link` parameter).
#' @param day_of_week_eff_prior_scales Normal prior
#' scales for the day of the week effect on observation
#' probability, relative to the reference day of the week.
#' Should be a vector of length 6.
#' Specified on the transformed scale (see `link` parameter).
#' @param non_obs_effect_prior_mode Normal prior
#' mode for the change in the observation probability
#' during the nonobservation (seeding) period. Useful
#' for model initialization. Should typically be a large
#' negative number.
#' Specified on the transformed scale (see `link` parameter).
#' @param non_obs_effect_prior_scale Normal prior
#' scalefor the change in the observation probability
#' during the nonobservation (seeding) period. Useful
#' for model initialization. Should typically be a small
#' number, to enforce the large negative effect given in
#' non_obs_effect_prior_mode.
#' Specified on the transformed scale (see `link` parameter).
#' @param inv_dispersion_prior_mode Normal prior mode
#' for the reciprocal dispersion of the negative binomial
#' observation process.
#' @param inv_dispersion_prior_mode Normal prior scale
#' for the reciprocal dispersion of the negative binomial
#' observation process.
#' @param link link function for the observation model,
#' passed as the `link` parameter to [epidemia::epiobs()]
#' Default `"logit"`.
#' @return the observation model, as the output
#' of an [epidemia::epiobs()] call.
#' @export
build_light_obs <- function(inf_to_hosp_dist,
                            ihr_intercept_prior_mode,
                            ihr_intercept_prior_scale,
                            day_of_week_eff_prior_modes,
                            day_of_week_eff_prior_scales,
                            holiday_eff_prior_mode,
                            holiday_eff_prior_scale,
                            post_holiday_eff_prior_mode,
                            post_holiday_eff_prior_scale,
                            non_obs_effect_prior_mode,
                            non_obs_effect_prior_scale,
                            inv_dispersion_prior_mode,
                            inv_dispersion_prior_scale,
                            link = "logit") {
  return(epidemia::epiobs(
    formula = as.formula(paste0(
      "hosp ~ 1 + day_of_week + ",
      "is_holiday + ",
      "is_post_holiday + ",
      "nonobservation_period"
    )),
    ## Add a covariate for the
    ## nonobservation window to
    ## leave an initial evolution
    ## period with no observations
    i2o = inf_to_hosp_dist,
    link = link,
    family = "neg_binom",
    prior_intercept = rstanarm::normal(
      location = ihr_intercept_prior_mode,
      scale = ihr_intercept_prior_scale
    ),
    prior = rstanarm::normal(
      location = c(
        day_of_week_eff_prior_modes,
        holiday_eff_prior_mode,
        post_holiday_eff_prior_mode,
        non_obs_effect_prior_mode
      ),
      ## a large negative non_obs_effect
      ## effectively conditions on detection
      ## prob = 0 outside the observation period
      scale = c(
        day_of_week_eff_prior_scales,
        holiday_eff_prior_scale,
        post_holiday_eff_prior_scale,
        non_obs_effect_prior_scale
        ## non-obs prior scale
        ## should be small to
        ## enforce non-obs effect
        ## close to (large negative) mode
      )
    ),
    prior_aux = rstanarm::normal(
      location = inv_dispersion_prior_mode,
      scale = inv_dispersion_prior_scale
    )
  ))
}

#' Build a complete "covariate light" epidemia
#' model
#'
#' For the given state with
#' the given parameter list
#'
#' @param state state for which to build the model
#' @param clean_data data frame of all fitting data
#' @param params the parameter list
#' @param n_warmup number of warmup samples for Stan to draw per chain.
#' Default `1000`.
#' @param n_iter total number of iterations for Stan per chain.
#' Default `2000`.
#' @param n_chains number of separate NUTS chains to run.
#' Default `4`.
#' @param max_treedepth maximum treedepth for NUTS,
#' passed to [rstan::sampling()]. Default `11`.
#' @param adapt_delta target acceptance probability
#' for NUTS adaptation, passed to [rstan::sampling()].
#' Default `0.85`.
#' @param refresh How often to print Stan progress
#' to terminal. Default `0` (never).
#' @return a list of arguments that can be passed
#' to [epidemia::epim()]
#' @export
build_state_light_model <- function(
    state,
    clean_data,
    params,
    n_warmup = 1000,
    n_iter = 2000,
    n_chains = 4,
    max_treedepth = 11,
    adapt_delta = 0.85,
    refresh = 0) {
  rw_prior_scale <- params$weekly_rw_prior_scale
  rt_model <- build_light_rt(
    params$rt_intercept_prior_mode,
    params$rt_intercept_prior_scale,
    params$max_rt,
    params$weekly_rw_prior_scale
  )
  ## make sure day_of_week is properly
  ## set up as a factor
  dow_levels <- levels(
    lubridate::wday("2023-01-01",
      label = TRUE,
      week_start = params$reference_day_of_week
    )
  )
  clean_data <- clean_data |>
    dplyr::mutate(
      day_of_week = factor(day_of_week,
        ordered = FALSE,
        levels = dow_levels
      )
    )
  # create the mean infections per day to use in prior_seeds
  # to population adjust the seeded infections
  mode_ihr <- plogis(params$ihr_intercept_prior_mode)
  state_data <- clean_data |>
    dplyr::filter(location == !!state)
  mean_inf_df <- state_data |>
    dplyr::distinct(location, population, first_week_hosp) |>
    dplyr::mutate(
      mean_seed_inf_per_day = (
        (params$inf_model_prior_infections_per_capita * population) +
          (first_week_hosp / (!!mode_ihr * 7))
      )
    )

  mean_inf_val <- mean_inf_df$mean_seed_inf_per_day[1]
  infection_model <- epidemia::epiinf(
    params$generation_time_dist,
    seed_days = params$inf_model_seeds,
    prior_seeds = rstanarm::exponential(1 / mean_inf_val),
    pop_adjust = TRUE,
    pops = "population",
    prior_susc = rstanarm::normal(
      location = params$susceptible_fraction_prior_mode,
      scale = params$susceptible_fraction_prior_scale
    )
  )
  obs_model <- build_light_obs(
    params$inf_to_hosp_dist,
    params$ihr_intercept_prior_mode,
    params$ihr_intercept_prior_scale,
    params$day_of_week_effect_prior_modes,
    params$day_of_week_effect_prior_scales,
    params$holiday_eff_prior_mode,
    params$holiday_eff_prior_scale,
    params$post_holiday_eff_prior_mode,
    params$post_holiday_eff_prior_scale,
    params$non_obs_effect_prior_mode,
    params$non_obs_effect_prior_scale,
    params$reciprocal_dispersion_prior_mode,
    params$reciprocal_dispersion_prior_scale
  )
  stan_data <- state_data |>
    dplyr::select(
      date,
      location,
      population,
      hosp,
      day_of_week,
      is_holiday,
      is_post_holiday,
      recency,
      nonobservation_period,
      week
    )
  aug_stan_data <- add_pre_observation_period(
    stan_data,
    params$n_pre_observation_days
  )
  epim_args <- list(
    rt = rt_model,
    obs = obs_model,
    inf = infection_model,
    data = aug_stan_data,
    warmup = n_warmup,
    iter = n_iter,
    seed = params$seed,
    chains = n_chains,
    refresh = refresh,
    control = list(
      max_treedepth = max_treedepth,
      adapt_delta = adapt_delta
    )
  )
  return(epim_args)
}
```

### [`fit.R`](#fitR)

```R
#!/usr/bin/env Rscript

#' fit forecast models for a given report date
#'
#' @param report_date report date for which
#' to run the analysis
#' @param output_parent_directory report will
#' be saved in a subdirectory named after the report date,
#' but within this parent directory. Defaults to creating
#' and/or using a directory named `"output"` within the
#' current working directory for this purpose.
#' @param data_cutoff_date Unless use data through
#' the given date. If `NULL`, use all
#' available data. Default `NULL`.
#' @param locations Only fit these locations.
#' If `NULL`, use all available locations.
#' Default `NULL`.
#' @param param_path Where to look for a parameter
#' file. Default to a file named `"params.toml"`
#' within a directory named `"data"` within the
#' current working directory.
#' @param location_data_path Where to look for a FluSight
#' `locations.csv` containing locations to fit and their
#' populations. Default to a file named `"locations.csv"`
#' within a directory named `"data"` within the
#' current working directory.
#' @param healthdata_api_key_id API key ID for authenticating
#' to HealthData.gov SODA API. Not required, but polite.
#' Default `NULL`
#' @param healthdata_api_key_secret Corresponding
#' API key secrete for authenticating
#' to HealthData.gov SODA API. Not required, but polite.
#' Default `NULL`.
#' @param overwrite_params Overwrite an existing
#' archived parameter file if it exists?
#' Boolean, default `FALSE`. If `FALSE`
#' and an archived parameter file already
#' exists, the pipeline will error out.
#' @return `TRUE` on success.
fit <- function(report_date,
                output_parent_directory = "output",
                data_cutoff_date = NULL,
                locations = NULL,
                param_path = fs::path("data", "params.toml"),
                location_data_path = fs::path("data", "locations.csv"),
                healthdata_api_key_id = NULL,
                healthdata_api_key_secret = NULL,
                overwrite_params = FALSE) {
  cli::cli_inform("Using working directory {fs::path_wd()}")

  report_outdir <- fs::path(
    output_parent_directory,
    report_date
  )

  fs::dir_create(report_outdir)

  data_save_path <- fs::path(
    report_outdir,
    paste0(report_date, "_clean_data", ".tsv")
  )

  param_save_path <- fs::path(
    report_outdir,
    paste0(report_date, "_config", ".toml")
  )

  cli::cli_inform("reading in run parameters from {param_path}")
  params <- RcppTOML::parseTOML(param_path)

  cli::cli_inform("Archiving parameters at {param_save_path}")
  fs::file_copy(param_path,
    param_save_path,
    overwrite = overwrite_params
  )

  cli::cli_inform("Pulling and cleaning data")
  clean_data <- cfaepim::get_data(
    params$first_fitting_date,
    location_data_path,
    api_key_id = healthdata_api_key_id,
    api_key_secret = healthdata_api_key_secret,
    recency_effect_length = params$recency_effect_length
  )

  for (loc in unique(clean_data$location)) {
    loc_start_date <- params$location_specific_start_dates[[loc]]
    loc_cutoff_date <- params$location_specific_cutoff_dates[[loc]]

    if (!is.null(loc_start_date)) {
      cli::cli_inform(paste0(
        "Using custom start date {loc_start_date} ",
        "for location {loc}"
      ))
      clean_data <- clean_data |>
        dplyr::filter(location != !!loc | date >= !!loc_start_date)
    }

    if (!is.null(loc_cutoff_date)) {
      cli::cli_inform(paste0(
        "Using custom cutoff date {loc_cutoff_date} ",
        "for location {loc}"
      ))
      clean_data <- clean_data |>
        dplyr::filter(location != !!loc | date <= !!loc_cutoff_date)
    }
  }

  if (!is.null(data_cutoff_date)) {
    clean_data <- clean_data |>
      dplyr::filter(date <= data_cutoff_date)
  }

  unobserved_dates <- params$location_specific_excluded_dates |>
    stack() |>
    tibble::as_tibble() |>
    dplyr::mutate(
      date = as.Date(values),
      location = ind,
      nonobservation_period = TRUE
    ) |>
    dplyr::select(
      date,
      location,
      nonobservation_period
    )

  clean_data <- clean_data |>
    dplyr::left_join(
      unobserved_dates,
      by = c("location", "date")
    ) |>
    dplyr::mutate(
      nonobservation_period =
        tidyr::replace_na(
          nonobservation_period,
          FALSE
        )
    )


  cli::cli_inform("Archiving cleaned data at {data_save_path}")
  readr::write_tsv(clean_data, data_save_path)

  if (!is.null(locations)) {
    loc_vec <- as.character(locations)
  } else {
    loc_vec <- clean_data |>
      dplyr::distinct(location) |>
      dplyr::pull()
  }
  names(loc_vec) <- loc_vec

  cli::cli_alert("Fitting the following locations: {loc_vec}")

  cli::cli_alert("Setting up models")
  fitting_args <- lapply(loc_vec,
    cfaepim::build_state_light_model,
    clean_data = clean_data,
    params = params,
    adapt_delta = params$mcmc$adapt_delta,
    max_treedepth = params$mcmc$max_treedepth,
    n_chains = params$mcmc$n_chains,
    n_warmup = params$mcmc$n_warmup,
    n_iter = params$mcmc$n_iter
  )

  cli::cli_alert("{length(fitting_args)} models to fit")
  cli::cli_alert("Starting model fit at {Sys.time()}")

  raw_results <- cfaepim::fit_future(
    fitting_args,
    save_results = TRUE,
    overwrite_existing = FALSE,
    save_dir = report_outdir,
    save_filename_pattern = paste0("_", report_date, "_epim_results")
  )

  print(raw_results[[1]])

  cli::cli_alert("Model fit finished at {Sys.time()}")

  return(TRUE)
}

argv_parser <- argparser::arg_parser(
  paste0(
    "Run Epidemia forecast analysis ",
    "for a given report date"
  )
) |>
  argparser::add_argument(
    "report_date",
    help = "Date for which to generate a forecast report"
  ) |>
  argparser::add_argument(
    "--data-cutoff",
    help = "Only use data up to this date for forecasting"
  ) |>
  argparser::add_argument(
    "--locations",
    help = "Only fit to these locations"
  ) |>
  argparser::add_argument(
    "--outdir",
    help = paste0(
      "Write forecast output to a timestamped ",
      "subdirectory of this directory"
    ),
    default = "output"
  ) |>
  argparser::add_argument(
    "--params",
    help = "Path to parameter file",
    default = "data/params.toml"
  ) |>
  argparser::add_argument(
    "--overwrite-params",
    help = "Overwrite an existing archived parameter file?",
    default = FALSE
  )

argv <- argparser::parse_args(argv_parser)

n_cores_use <- parallel::detectCores() - 1
future::plan(future::multicore(workers = n_cores_use))

if (is.na(argv$data_cutoff)) {
  argv$data_cutoff <- NULL
}
if (is.na(argv$locations)) {
  argv$locations <- NULL
} else {
  argv$locations <- unlist(strsplit(
    argv$locations,
    " "
  ))
}

## hack to make argparser slightly more system-agnostic
if (argv$params == "data/params.toml") {
  argv$params <- fs::path("data", "params.toml")
}

api_creds <- cfaepim::get_api_credentials()

fit(
  argv$report_date,
  argv$outdir,
  data_cutoff_date = argv$data_cutoff,
  locations = argv$locations,
  param_path = argv$params,
  healthdata_api_key_id = api_creds$id,
  healthdata_api_key_secret = api_creds$key,
  overwrite_params = argv$overwrite_params
)

```

### [`forecast.R`](#forecastR)

```R
#' synthetic_forecast_data
#'
#' Given a dataframe of timeseries data used
#' for epidemia model fitting,
#' produce a synthetic dataframe
#' in the same format to use for
#' forward projection. This is required
#' because the rstanarm::posterior_predict
#' function that epidemia uses expects a
#' dataframe in the same format as the one
#' used to fit, with both covariates and
#' (unused) observations
#'
#' @param data data frame used for model fitting
#' @param start_date first date to forecast
#' @param end_date last date to forecast
#' @return tibble of synthetic data
#' @export
synthetic_forecast_data <- function(data,
                                    start_date,
                                    end_date) {
  data <- data |> dplyr::ungroup()
  first_forecast_date <- lubridate::ymd(start_date)
  last_forecast_date <- lubridate::ymd(end_date)
  last_data_date <- as.Date(max(data$date))
  last_data_week <- max(data$week)

  if (last_forecast_date > last_data_date) {
    new_dates <- seq(
      last_data_date + 1,
      last_forecast_date,
      by = "day"
    )

    ## index synthetic weeks to weeks as
    ## in the dataset
    n_days_final_week <- data |>
      dplyr::filter(week == !!last_data_week) |>
      dplyr::pull() |>
      length()

    if (n_days_final_week > 7) {
      cli::cli_abort(paste0(
        "Final week in dataset to ",
        "augment contains more than ",
        "seven entries; check the dataset"
      ))
    } else if (n_days_final_week < 1) {
      cli::cli_abort(paste0(
        "Final week in dataset to ",
        "augment contains no entries; ",
        "check the dataset"
      ))
    }

    last_week_day_count <- (n_days_final_week - 1L)

    new_weeks <- (
      last_data_week + floor(as.numeric(
        new_dates - last_data_date + last_week_day_count,
        "weeks"
      ))
    )

    holidays <- as.Date(c(
      "2023-11-23",
      "2023-12-25",
      "2023-12-31",
      "2024-01-01"
    ))

    new_rows <- tibble::tibble(
      date = !!new_dates,
      week = !!new_weeks,
      location = !!data$location[1],
      hosp = 9999,
      population = !!data$population[1]
    ) |>
      add_date_properties(recency_effect_length = 0)

    result <- dplyr::bind_rows(data, new_rows) |>
      dplyr::distinct(date, .keep_all = TRUE)
  } else {
    result <- data
  }

  result <- result |>
    dplyr::mutate(
      nonobservation_period = 0L,
      hosp = ifelse(date >= first_forecast_date,
        hosp,
        NA ## only forecast needed days
      )
    ) |>
    dplyr::select(-group)
  return(result)
}

#' forecast
#'
#' Given an epidemia model fit (`epimodel` object),
#' the data used to fit it, and the final day of the
#' forecast period, return a set of forecasts (
#' as well as posterior predictive retrocasts
#' for the fitting period, for the given signals.
#'
#' @param fit epidemia model fit as an `epimodel` object.
#' @param start_date first day of the forecast period
#' @param end_date last day of the forecast period
#' @param signals vector of signals to forecast. Default `c('hosp')`.
#' @param seed seed for the posterior predictive pseudorandom
#' number generator, passed to [epidemia::posterior_predict()].
#' Default `NULL`.
#' @return posterior predictive output, in the list format
#' generated by `rstanarm::posterior_predict`
#' @export
forecast <- function(fit,
                     start_date,
                     end_date,
                     signals = c("hosp"),
                     seed = NULL) {
  old_data <- fit$data
  forecast_synth_data <- synthetic_forecast_data(
    old_data,
    start_date,
    end_date
  )

  return(epidemia::posterior_predict(fit,
    newdata = forecast_synth_data,
    types = signals,
    seed = seed
  ))
}


#' pivot_forecast_to_long
#'
#' Take in the output of `rstanarm::posterior_predict`
#' and return a tidy tibble of long-form posterior
#' predictive draws.
#'
#' @param forecast output of `rstanarm::posterior_predict`
#' to pivot.
#' @param signal_name name of the signal being forecast.
#' Default 'hosp'.
#' @param time_name name for the column that will contain
#' the values of the `forecast$time` vector. Default
#' "date".
#' @return the forecast pivoted to tidy long format
#' @export
pivot_forecast_to_long <- function(forecast,
                                   signal_name = "hosp",
                                   time_name = "date") {
  draws_wide <- tibble::tibble(as.data.frame(forecast$draws))
  names(draws_wide) <- forecast$time
  draws_long <- draws_wide |>
    dplyr::mutate(
      .draw = dplyr::row_number()
    ) |>
    tidyr::pivot_longer(
      cols = -.draw,
      names_to = time_name,
      values_to = signal_name
    )
  return(draws_long)
}

#' Produce a daily forecast for a given state
#'
#' @param state_abbr State to forecast, as
#' two-letter USPS abbreviation
#' @param results_list A list of `epimodel`` objects,
#' each corresponding to a single state fit.
#' @param start_date First date to forecast
#' @param end_date Last date to forecast
#' @param fitting_data data used to fit the model
#' @param seed seed for the pseudorandom number
#' generator for posterior prediction (passed to
#' [epidemia::posterior_predict()]. Default `NULL`.
#' @param verbose Boolean. Give verbose output
#' to the terminal? Default `FALSE`.
#' @return state forecast, as a .draw-indexed, tidy
#' [tibble::tibble] object.
#' @export
daily_state_forecast <- function(state_abbr,
                                 results_list,
                                 start_date,
                                 end_date,
                                 fitting_data,
                                 seed = NULL,
                                 verbose = FALSE) {
  state_result <- results_list[[state_abbr]]
  state_data <- fitting_data |>
    dplyr::filter(location == !!state_abbr)


  if (!all(state_result$data$location == state_abbr)) {
    cli::cli_abort(paste0(
      "Could not find a result in the provided ",
      "`results_list` whose fitting data matched ",
      "the provided state abbreviation ",
      "{state_abbr}. Check that the abbreviation ",
      "is correct and that the indices of ",
      "`results_list` and the values of ",
      "`data$location` for the entries of that ",
      "list are two-letter USPS state abbreviations."
    ))
  }

  if (verbose) {
    cli::cli_inform("Forecasting for {state_abbr}\n")
  }

  state_forecast <- forecast(
    state_result,
    start_date,
    end_date,
    seed = seed
  ) |>
    pivot_forecast_to_long() |>
    dplyr::filter(date >= as.Date(!!start_date))

  return(state_forecast)
}


#' Forecast hospitalizations and
#' output them in FluSight format
#'
#' @param data all data (unfilted by location)
#' data used to fit the models, as a `tibble`
#' @param results epidemia results, saved
#' as a list of `epimodel` objects
#' @param output_path Path to save the FluSight formatted
#' .csv file.
#' @param reference_date reference date for the forecast.
#' Should typically be the Saturday that concludes an
#' epiweek.
#' @param horizons vector of forecast horizons to compute,
#' in weeks ahead of the reference_date.
#' Default `-1:3` (FluSight 2023/24 requested horizons)
#' @param seed seed for the posterior predictive
#' pseudorandom random number generator, passed
#' to [epidemia::posterior_predict()]. Default `NULL`.
#' @return The formatted output that has been
#' saved to disk, as a [tibble::tibble()], on
#' success.
#' @export
forecast_and_output_flusight <- function(
    data,
    results,
    output_path,
    reference_date,
    horizons = -1:3,
    seed = NULL) {
  set.seed(seed)

  nation_state_crosswalk <- forecasttools::flusight_location_table


  cli::cli_inform("Producing daily state forecasts...")

  start_date <- (
    lubridate::date(reference_date) +
      lubridate::weeks(min(horizons)) -
      lubridate::weeks(1) -
      lubridate::days(1)
  )

  end_date <- (
    lubridate::date(reference_date) +
      lubridate::weeks(max(horizons)) +
      lubridate::days(1)
  )

  state_vec <- names(results)
  names(state_vec) <- state_vec

  state_daily_forecast_list <- lapply(
    state_vec,
    daily_state_forecast,
    results_list = results,
    start_date = start_date,
    end_date = end_date,
    fitting_data = data,
    verbose = TRUE,
    seed = 62352
  )

  cli::cli_inform("Summarizing daily forecasts to epiweekly...")

  state_weekly_forecasts <- future.apply::future_lapply(
    state_daily_forecast_list,
    forecasttools::daily_to_epiweekly,
    value_col = "hosp",
    id_cols = c(".draw"),
    weekly_value_name = "weekly_hosp"
  )

  cli::cli_inform("Formatting output for FluSight...")

  state_flusight_tables <- list()
  full_table <- tibble::tibble()

  for (state in names(state_weekly_forecasts)) {
    state_flusight_table <- forecasttools::trajectories_to_quantiles(
      state_weekly_forecasts[[state]],
      timepoint_cols = c("epiweek", "epiyear"),
      value_col = "weekly_hosp"
    ) |>
      dplyr::mutate(
        location = forecasttools::loc_abbr_to_flusight_code(state)
      ) |>
      forecasttools:::get_flusight_table(
        reference_date,
        horizons = horizons
      )

    full_table <- dplyr::bind_rows(
      full_table,
      state_flusight_table
    )
  }

  full_table <- full_table |>
    dplyr::arrange(
      location,
      reference_date,
      horizon,
      output_type,
      output_type_id
    )
  readr::write_csv(
    full_table,
    output_path
  )
  return(full_table)
}
```

## [A Worked Example](#worked)

__Problem__: Suppose you reside in a jurisdiction of 500000 individuals. There is an influenza outbreak, and you know that as of today, Tuesday 2024-09-03 (one day after labor day), the reported hospitalizations for the last four days (including today) have been 12, 15, 26, and 32, respectively. Forecast the next two days of influenza hospitalizations using the `cfaepim` model presets, where applicable.

__Answer__: With the problem statement, know that the popluation $P = 500000$ and the reported influenza hospitalizations $Y = (Y_1, \dotsc, Y_4) = (12, 15, 26, 32)$. From `cfaepim`, the infections per capita $\Omega = 0.0001$. For the mean infected individuals per day during the seeding period we have

$$
\begin{aligned}
\exp \bigg( \frac{1}{\Omega P + \frac{12 + 15 + 26 + 32}{\frac{1}{1 + e^{-(-6.5)}} \cdot 4}}\bigg)
\end{aligned}
$$

<!--
## Interesting

### Transmission Component, As Code In Python

In Python, the transmission component, using the `cfaepim` presets, could be written in the following manner (note that plotting code is not included):

```python
import numpy as np


def inverse_link(x, K):
    return K / (1 + np.exp(-x))


# parameters
K = 3.0
max_rt = 3.0
rt_intercept_prior_mode = -0.4054651
rt_intercept_prior_scale = 0.3
weekly_rw_prior_scale = 0.25
n_weeks = 52

# generate beta_0 intercept w/ prior
np.random.seed(343)
beta_0 = np.random.normal(
        rt_intercept_prior_mode, rt_intercept_prior_scale)

# generate random walk W_t
W = np.zeros(n_weeks)
np.random.seed(43)
gamma = np.random.normal(
    0, weekly_rw_prior_scale, n_weeks)
for t in range(1, n_weeks):
    W[t] = W[t-1] + gamma[t]

# linear predictors
eta = beta_0 + W

# effective reproduction numbers
R_ts = inverse_link(eta, K)
```

![Example transmission component, i.e. $\mathscr{R}_t$ estimates, using `cfaepim` presets. This is the `R_ts` in the Python code example.](./figures/transmission_eg.png){ width=100% } -->



##  [Resources](#resources)

Pending.


# References

::: {#refs}
:::
