=============================
Fitting a basic renewal model
=============================

.. raw:: html

   <!--
   WARNING
   This file was generated by quarto from a .qmd
   formatted source file. Do not edit this file by hand.

   For the source file, see:
   <https://github.com/CDCgov/multisignal-epi-inference/tree/main/docs/source/tutorials/basic_renewal_model.qmd>
   -->

This document will show the steps to build a simple renewal model
featuring a latent infection process, a random walk Rt process, and an
observation process for the reported infections.

We start by loading the needed components to build a basic renewal
model:

.. container:: cell
   :name: loading-pkgs

   .. code:: python

      import jax.numpy as jnp
      import numpy as np
      import numpyro
      import numpyro.distributions as dist
      from pyrenew.process import SimpleRandomWalkProcess
      from pyrenew.latent import (
          Infections,
          InfectionInitializationProcess,
          InitializeInfectionsZeroPad,
      )
      from pyrenew.observation import PoissonObservation
      from pyrenew.deterministic import DeterministicPMF
      from pyrenew.model import RtInfectionsRenewalModel
      from pyrenew.metaclass import (
          RandomVariable,
          DistributionalRV,
          TransformedRandomVariable,
      )
      import pyrenew.transformation as t
      from numpyro.infer.reparam import LocScaleReparam

By default, XLA (which is used by JAX for compilation) considers all CPU
cores as one device. Depending on your system’s configuration, we
recommend using numpyro’s
`set_host_device_count() <https://num.pyro.ai/en/stable/utilities.html#set-host-device-count>`__
function to set the number of devices available for parallel computing.
Here, we set the device count to be 2.

.. container:: cell
   :name: set-device-count

   .. code:: python

      numpyro.set_host_device_count(2)

Architecture of ``RtInfectionsRenewalModel``
============================================

``pyrenew`` leverages ``numpyro``\ ’s flexibility to build models via
composition. As a principle, most objects in ``pyrenew`` can be treated
as random variables we can sample. At the top-level ``pyrenew`` has two
metaclasses from which most objects inherit: ``RandomVariable`` and
``Model``. From them, the following four sub-modules arise:

-  The ``process`` sub-module,
-  The ``deterministic`` sub-module,
-  The ``observation`` sub-module,
-  The ``latent`` sub-module, and
-  The ``models`` sub-module

The first four are collections of instances of ``RandomVariable``, and
the last is a collection of instances of ``Model``. The following
diagram shows a detailed view of how metaclasses, modules, and classes
interact to create the ``RtInfectionsRenewalModel`` instantiated in the
next section:

.. mermaid::

   %%| label: overview-of-RtInfectionsRenewalModel
   %%| include: true
   flowchart LR
       rand((RandomVariable\nmetaclass))
       models((Model\nmetaclass))

       subgraph observations[Observations module]
           obs["infection_obs_process_rv\n(PoissonObservation)"]
       end

       subgraph latent[Latent module]
           inf["latent_infections_rv\n(Infections)"]
           i0["I0_rv\n(DistributionalRV)"]
       end

       subgraph process[Process module]
           rt["Rt_process_rv\n(Custom class built using SimpleRandomWalk)"]
       end

       subgraph deterministic[Deterministic module]
           detpmf["gen_int_rv\n(DeterministicPMF)"]
       end

       subgraph model[Model module]
           model1["model1\n(RtInfectionsRenewalModel)"]
       end

       rand-->|Inherited by|observations
       rand-->|Inherited by|process
       rand-->|Inherited by|latent
       rand-->|Inherited by|deterministic
       models-->|Inherited by|model

       detpmf-->|Composes|model1
       i0-->|Composes|model1
       rt-->|Composes|model1
       obs-->|Composes|model1
       inf-->|Composes|model1

The pyrenew package models the real-time reproductive number
:math:`\mathcal{R}(t)`, the average number of secondary infections
caused by an infected individual, as a renewal process model. Our basic
renewal process model defines five components:

(1) generation interval, the times between infections

(2) initial infections, occurring prior to time :math:`t = 0`

(3) :math:`\mathcal{R}(t)`, the time-varying reproductive number,

(4) latent infections, i.e., those infections which are known to exist
    but are not observed (or not observable), and

(5) observed infections, a subset of underlying true infections that are
    reported, perhaps via hospital admissions, physician’s office
    visits, or routine biosurveillance.

To initialize these five components within the renewal modeling
framework, we estimate each component with:

(1) In this example, the generation interval is not estimated but passed
    as a deterministic instance of ``RandomVariable``

(2) an instance of the ``InfectionInitializationProcess`` class, where
    the number of latent infections immediately before the renewal
    process begins follows a log-normal distribution with mean = 0 and
    standard deviation = 1. By specifying
    ``InitializeInfectionsZeroPad``, the latent infections before this
    time are assumed to be 0.

(3) A process to represent :math:`\mathcal{R}(t)` as a random walk on
    the log scale, with an inferred initial value and a fixed Normal
    step-size distribution. For this, we construct a custom
    ``RandomVariable``, ``MyRt``.

(4) an instance of the ``Infections`` class with default values, and

(5) an instance of the ``PoissonObservation`` class with default values

.. container:: cell
   :name: creating-elements

   .. code:: python

      # (1) The generation interval (deterministic)
      pmf_array = jnp.array([0.4, 0.3, 0.2, 0.1])
      gen_int = DeterministicPMF(name="gen_int", value=pmf_array)

      # (2) Initial infections (inferred with a prior)
      I0 = InfectionInitializationProcess(
          "I0_initialization",
          DistributionalRV(name="I0", dist=dist.LogNormal(2.5, 1)),
          InitializeInfectionsZeroPad(pmf_array.size),
          t_unit=1,
      )


      # (3) The random walk on log Rt, with an inferred s.d. Here, we
      # construct a custom RandomVariable.
      class MyRt(RandomVariable):

          def validate(self):
              pass

          def sample(self, n_steps: int, **kwargs) -> tuple:
              sd_rt = numpyro.sample("Rt_random_walk_sd", dist.HalfNormal(0.025))

              rt_rv = TransformedRandomVariable(
                  "Rt_rv",
                  base_rv=SimpleRandomWalkProcess(
                      name="log_rt",
                      step_rv=DistributionalRV(
                          name="rw_step_rv",
                          dist=dist.Normal(0, sd_rt),
                          reparam=LocScaleReparam(0),
                      ),
                      init_rv=DistributionalRV(
                          name="init_log_rt",
                          dist=dist.Normal(jnp.log(1), jnp.log(1.2)),
                      ),
                  ),
                  transforms=t.ExpTransform(),
              )
              return rt_rv.sample(n_steps=n_steps, **kwargs)


      rt_proc = MyRt()

      # (4) Latent infection process (which will use 1 and 2)
      latent_infections = Infections()

      # (5) The observed infections process (with mean at the latent infections)
      observation_process = PoissonObservation("poisson_rv")

With these five pieces, we can build the basic renewal model as an
instance of the ``RtInfectionsRenewalModel`` class:

.. container:: cell
   :name: model-creation

   .. code:: python

      model1 = RtInfectionsRenewalModel(
          gen_int_rv=gen_int,
          I0_rv=I0,
          Rt_process_rv=rt_proc,
          latent_infections_rv=latent_infections,
          infection_obs_process_rv=observation_process,
      )

The following diagram summarizes how the modules interact via
composition; notably, ``gen_int``, ``I0``, ``rt_proc``,
``latent_infections``, and ``observed_infections`` are instances of
``RandomVariable``, which means these can be easily replaced to generate
a different instance of the ``RtInfectionsRenewalModel`` class:

.. mermaid::

   %%| label: overview-of-RtInfectionsRenewalModel
   %%| include: true
   flowchart TB
       genint["(1) gen_int\n(DetermnisticPMF)"]
       i0["(2) I0\n(InfectionInitializationProcess)"]
       rt["(3) rt_proc\n(MyRt, the custom RV defined above)"]
       inf["(4) latent_infections\n(Infections)"]
       obs["(5) observation_process\n(PoissonObservation)"]

       model1["model1\n(RtInfectionsRenewalModel)"]

       i0-->|Composes|model1
       genint-->|Composes|model1
       rt-->|Composes|model1
       obs-->|Composes|model1
       inf-->|Composes|model1

Using ``numpyro``, we can simulate data using the ``sample()`` member
function of ``RtInfectionsRenewalModel``. The ``sample()`` method of the
``RtInfectionsRenewalModel`` class returns a list composed of the ``Rt``
and ``infections`` sequences, called ``sim_data``:

.. container:: cell

   .. code:: python

      with numpyro.handlers.seed(rng_seed=53):
          sim_data = model1.sample(n_datapoints=40)

      sim_data

   .. container:: cell-output cell-output-display
      :name: simulate

      ::

         RtInfectionsRenewalSample(Rt=SampledValue(value=[      nan       nan       nan       nan 1.0176641 1.0184904 1.0177932
          1.0244688 1.0195822 1.0306455 1.0333241 1.0274749 1.0298989 1.0335226
          1.0335467 1.0344427 1.0379399 1.0409551 1.0444484 1.0490868 1.0552745
          1.0502815 1.0540576 1.0458511 1.0501264 1.0488535 1.0491227 1.0483501
          1.0463624 1.0448525 1.0446872 1.0518403 1.0626695 1.053049  1.0584316
          1.0540105 1.0508252 1.0472085 1.0537769 1.0561432 1.0608149 1.06833
          1.0660552 1.07087  ], t_start=None, t_unit=None), latent_infections=SampledValue(value=[ 0.         0.         0.        28.330536  11.532388  13.354565
          14.725075  15.403842  14.685258  15.228538  15.5518055 15.686172
          15.916309  16.232082  16.49555   16.778376  17.123997  17.493698
          17.901749  18.371027  18.921152  19.335146  19.89511   20.268513
          20.829346  21.317768  21.841818  22.355835  22.853987  23.350874
          23.873081  24.57191   25.446962  25.968254  26.802752  27.465578
          28.125761  28.743103  29.61994   30.461933  31.434013  32.595264
          33.604927  34.86062  ], t_start=None, t_unit=None), observed_infections=SampledValue(value=[ 0  0  0  0  8 12 15 17 12 14 18 20 17 25  9 22 17 23 16 15 19 17 26 13
          33 24 20 34 16 25 31 27 29 26 24 19 28 29 36 33 26 42 37 40], t_start=None, t_unit=None))

To understand what has been accomplished here, visualize an
:math:`\mathcal{R}(t)` sample path (left panel) and infections over time
(right panel):

.. container:: cell

   .. code:: python

      import matplotlib.pyplot as plt

      fig, axs = plt.subplots(1, 2)

      # Rt plot
      axs[0].plot(sim_data.Rt.value)
      axs[0].set_ylabel("Rt")

      # Infections plot
      axs[1].plot(sim_data.observed_infections.value)
      axs[1].set_ylabel("Infections")

      fig.suptitle("Basic renewal model")
      fig.supxlabel("Time")
      plt.tight_layout()
      plt.show()

   .. container:: cell-output cell-output-display

      |image1|

To fit the model, we can use the ``run()`` method of the
``RtInfectionsRenewalModel`` class (an inherited method from the
metaclass ``Model``). ``model1.run()`` will call the ``run`` method of
the ``model1`` object, which will generate an instance of model MCMC
simulation, with 2000 warm-up iterations for the MCMC algorithm, used to
tune the parameters of the MCMC algorithm to improve efficiency of the
sampling process. From the posterior distribution of the model
parameters, 1000 samples will be drawn and used to estimate the
posterior distributions and compute summary statistics. Observed data is
provided to the model using the ``sim_data`` object previously
generated. ``mcmc_args`` provides additional arguments for the MCMC
algorithm.

.. container:: cell
   :name: model-fit

   .. code:: python

      import jax

      model1.run(
          num_warmup=2000,
          num_samples=1000,
          data_observed_infections=sim_data.observed_infections.value,
          rng_key=jax.random.PRNGKey(54),
          mcmc_args=dict(progress_bar=False, num_chains=2),
      )

Now, let’s investigate the output, particularly the posterior
distribution of the :math:`\mathcal{R}(t)` estimates:

.. container:: cell

   .. code:: python

      out = model1.plot_posterior(var="Rt")

   .. container:: cell-output cell-output-display

      |image2|

We can use the ``get_samples`` method to extract samples from the model

.. container:: cell
   :name: get-model-fitted-samples

   .. code:: python

      Rt_samp = model1.mcmc.get_samples()["Rt"]
      latent_infection_samp = model1.mcmc.get_samples()["all_latent_infections"]

We can also convert the fitted model to
`ArviZ <https://www.arviz.org/>`__ InferenceData object and use ArviZ
package to extarct samples, calculate statistics, create model
diagnostics and visualizations.

.. container:: cell
   :name: convert-inference-data

   .. code:: python

      import arviz as az

      idata = az.from_numpyro(model1.mcmc)

and use the InferenceData to compute the model-fit diagnostics. Here, we
show diagnostic summary for the first 10 effective reproduction number
:math:`\mathcal{R}(t)`.

.. container:: cell
   :name: diagnostics

   .. code:: python

      diagnostic_stats_summary = az.summary(
          idata.posterior["Rt"][::, ::, 4:],  # ignore nan padding
          kind="diagnostics",
      )

      print(diagnostic_stats_summary)

   .. container:: cell-output cell-output-stdout

      ::

                 mcse_mean  mcse_sd  ess_bulk  ess_tail  r_hat
         Rt[4]       0.003    0.002    1825.0    1602.0   1.00
         Rt[5]       0.003    0.002    1892.0    1413.0   1.00
         Rt[6]       0.004    0.003    1907.0    1493.0   1.01
         Rt[7]       0.004    0.003    1606.0    1557.0   1.00
         Rt[8]       0.004    0.003    1223.0    1752.0   1.00
         Rt[9]       0.004    0.003    1260.0    1459.0   1.00
         Rt[10]      0.003    0.002    1353.0    1577.0   1.00
         Rt[11]      0.003    0.002    1697.0    1642.0   1.00
         Rt[12]      0.002    0.001    2704.0    1740.0   1.00
         Rt[13]      0.001    0.001    3414.0    1756.0   1.00
         Rt[14]      0.001    0.001    4193.0    1810.0   1.00
         Rt[15]      0.001    0.001    3507.0    1722.0   1.00
         Rt[16]      0.001    0.001    3146.0    1962.0   1.00
         Rt[17]      0.001    0.001    2665.0    1621.0   1.00
         Rt[18]      0.001    0.001    2499.0    1500.0   1.00
         Rt[19]      0.001    0.001    2570.0    1541.0   1.00
         Rt[20]      0.001    0.001    2622.0    1199.0   1.00
         Rt[21]      0.001    0.001    2438.0    1612.0   1.00
         Rt[22]      0.001    0.001    2576.0    1795.0   1.00
         Rt[23]      0.001    0.001    2731.0    1583.0   1.00
         Rt[24]      0.001    0.001    3343.0    1114.0   1.00
         Rt[25]      0.001    0.001    3241.0    1782.0   1.00
         Rt[26]      0.001    0.001    3589.0    1577.0   1.00
         Rt[27]      0.001    0.001    3831.0    1600.0   1.00
         Rt[28]      0.001    0.001    3080.0    1656.0   1.00
         Rt[29]      0.001    0.001    3194.0    1553.0   1.00
         Rt[30]      0.001    0.001    3251.0    1560.0   1.00
         Rt[31]      0.001    0.001    3220.0    1474.0   1.00
         Rt[32]      0.001    0.001    3583.0    1630.0   1.00
         Rt[33]      0.001    0.001    4042.0    1726.0   1.00
         Rt[34]      0.001    0.001    3729.0    1553.0   1.00
         Rt[35]      0.001    0.001    3072.0    1795.0   1.00
         Rt[36]      0.001    0.001    3848.0    1666.0   1.00
         Rt[37]      0.001    0.001    3305.0    1413.0   1.00
         Rt[38]      0.001    0.001    3223.0    1498.0   1.00
         Rt[39]      0.001    0.001    2856.0    1658.0   1.00
         Rt[40]      0.001    0.001    3191.0    1585.0   1.00
         Rt[41]      0.001    0.001    3328.0    1246.0   1.00
         Rt[42]      0.001    0.001    3102.0    1658.0   1.00
         Rt[43]      0.001    0.001    2523.0    1717.0   1.00
         Rt[44]      0.001    0.001    2759.0    1828.0   1.00
         Rt[45]      0.001    0.001    2844.0    1671.0   1.00
         Rt[46]      0.001    0.001    3038.0    1914.0   1.00
         Rt[47]      0.001    0.001    3292.0    1652.0   1.00

Below we use ``plot_trace`` to inspect the trace of the first 10
inferred :math:`\mathcal{R}(t)` values.

.. container:: cell

   .. code:: python

      plt.rcParams["figure.constrained_layout.use"] = True

      az.plot_trace(
          idata.posterior,
          var_names=["Rt"],
          coords={"Rt_dim_0": np.arange(4, 14)},
          compact=False,
      )
      plt.show()

   .. container:: cell-output cell-output-display

      |image3|

We inspect the posterior distribution of :math:`\mathcal{R}(t)` by
plotting the 90% and 50% highest density intervals:

.. container:: cell

   .. code:: python

      x_data = idata.posterior["Rt_dim_0"][4:]
      y_data = idata.posterior["Rt"][::, ::, 4:]

      fig, axes = plt.subplots(figsize=(6, 5))
      az.plot_hdi(
          x_data,
          y_data,
          hdi_prob=0.9,
          color="C0",
          fill_kwargs={"alpha": 0.3},
          ax=axes,
      )

      az.plot_hdi(
          x_data,
          y_data,
          hdi_prob=0.5,
          color="C0",
          fill_kwargs={"alpha": 0.6},
          ax=axes,
      )

      # Add mean of the posterior to the figure
      median_ts = y_data.median(dim=["chain", "draw"])
      axes.plot(x_data, median_ts, color="C0", label="Median")
      axes.legend()
      axes.set_title("Posterior Effective Reproduction Number", fontsize=10)
      axes.set_xlabel("Time", fontsize=10)
      axes.set_ylabel("$\\mathcal{R}(t)$", fontsize=10)
      plt.show()

   .. container:: cell-output cell-output-display

      |image4|

and latent infections:

.. container:: cell

   .. code:: python

      x_data = idata.posterior["all_latent_infections_dim_0"]
      y_data = idata.posterior["all_latent_infections"]

      fig, axes = plt.subplots(figsize=(6, 5))
      az.plot_hdi(
          x_data,
          y_data,
          hdi_prob=0.9,
          color="C0",
          smooth=False,
          fill_kwargs={"alpha": 0.3},
          ax=axes,
      )

      az.plot_hdi(
          x_data,
          y_data,
          hdi_prob=0.5,
          color="C0",
          smooth=False,
          fill_kwargs={"alpha": 0.6},
          ax=axes,
      )

      # plot the posterior median
      median_ts = y_data.median(dim=["chain", "draw"])
      axes.plot(x_data, median_ts, color="C0", label="Median")

      axes.legend()
      axes.set_title("Posterior Latent Infections", fontsize=10)
      axes.set_xlabel("Time", fontsize=10)
      axes.set_ylabel("Latent Infections", fontsize=10)
      plt.show()

   .. container:: cell-output cell-output-display

      |image5|

.. |image1| image:: basic_renewal_model_files/figure-rst/fig-basic-output-1.png
.. |image2| image:: basic_renewal_model_files/figure-rst/fig-output-rt-output-1.png
.. |image3| image:: basic_renewal_model_files/figure-rst/fig-trace-rt-output-1.png
.. |image4| image:: basic_renewal_model_files/figure-rst/fig-hdi-rt-output-1.png
.. |image5| image:: basic_renewal_model_files/figure-rst/fig-hdi-latent-infections-output-1.png
