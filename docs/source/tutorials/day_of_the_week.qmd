---
title: Implementing a Day of the Week Effect
format: gfm
engine: jupyter
---

This document illustrates how to leverage the time-aware arrays to create a a day of the week effect. We use the same model designed in the hospital admissions-only tutorial.

```{python}
# | label: setup
# Setup
import numpyro
import polars as pl
from pyrenew import datasets

# Setting the number of devices
numpyro.set_host_device_count(2)

# Loading and processing the data
dat = datasets.load_wastewater()

# Keeping the first observation of each date
dat = (
    dat.group_by("date")
    .first()
    .select(
        ["date", "daily_hosp_admits"],
    )
)

# Now, sorting by date
dat = dat.sort("date")

# Keeping the first 90 days
dat = dat.head(90)

daily_hosp_admits = dat["daily_hosp_admits"].to_numpy()
dates = dat["date"].to_numpy()

# Loading additional datasets
gen_int = datasets.load_generation_interval()
inf_hosp_int = datasets.load_infection_admission_interval()

# We only need the probability_mass column of each dataset
gen_int_array = gen_int["probability_mass"].to_numpy()
gen_int = gen_int_array
inf_hosp_int = inf_hosp_int["probability_mass"].to_numpy()
```

With these two in hand, we can start building the model. First, we will define the latent hospital admissions:

```{python}
# | label: latent-hosp
from pyrenew import latent, deterministic, metaclass
import jax.numpy as jnp
import numpyro.distributions as dist

inf_hosp_int = deterministic.DeterministicPMF(
    name="inf_hosp_int", value=inf_hosp_int
)

hosp_rate = metaclass.DistributionalRV(
    name="IHR", dist=dist.LogNormal(jnp.log(0.05), jnp.log(1.1))
)

latent_hosp = latent.HospitalAdmissions(
    infection_to_admission_interval_rv=inf_hosp_int,
    infect_hosp_rate_rv=hosp_rate,
)

from pyrenew import model, process, observation, metaclass, transformation
from pyrenew.latent import (
    InfectionInitializationProcess,
    InitializeInfectionsExponentialGrowth,
)


# Infection process
latent_inf = latent.Infections()
I0 = InfectionInitializationProcess(
    "I0_initialization",
    metaclass.DistributionalRV(
        name="I0", dist=dist.LogNormal(loc=jnp.log(100), scale=jnp.log(1.75))
    ),
    InitializeInfectionsExponentialGrowth(
        gen_int_array.size,
        deterministic.DeterministicVariable(name="rate", value=0.05),
    ),
    t_unit=1,
)

# Generation interval and Rt
gen_int = deterministic.DeterministicPMF(name="gen_int", value=gen_int)


class MyRt(metaclass.RandomVariable):
    def __init__(self, sd_rv):
        self.sd_rv = sd_rv

    def validate(self):
        pass

    def sample(self, n_steps: int, **kwargs) -> tuple:
        sd_rt, *_ = self.sd_rv()

        rt_rv = metaclass.TransformedRandomVariable(
            "Rt_rv",
            base_rv=process.SimpleRandomWalkProcess(
                name="log_rt",
                step_rv=metaclass.DistributionalRV(
                    name="rw_step_rv", dist=dist.Normal(0, sd_rt.value)
                ),
                init_rv=metaclass.DistributionalRV(
                    name="init_log_rt", dist=dist.Normal(0, 0.2)
                ),
            ),
            transforms=transformation.ExpTransform(),
        )

        return rt_rv.sample(n_steps=n_steps, **kwargs)


rtproc = MyRt(
    metaclass.DistributionalRV(
        name="Rt_random_walk_sd", dist=dist.HalfNormal(0.025)
    )
)

# The observation model

# we place a log-Normal prior on the concentration
# parameter of the negative binomial.
nb_conc_rv = metaclass.TransformedRandomVariable(
    "concentration",
    metaclass.DistributionalRV(
        name="concentration_raw",
        dist=dist.TruncatedNormal(loc=0, scale=1, low=0.01),
    ),
    transformation.PowerTransform(-2),
)

# now we define the observation process
obs = observation.NegativeBinomialObservation(
    "negbinom_rv",
    concentration_rv=nb_conc_rv,
)
```

Notice all the components are `RandomVariable` instances. We can now build the model:

```{python}
# | label: init-model
hosp_model = model.HospitalAdmissionsModel(
    latent_infections_rv=latent_inf,
    latent_hosp_admissions_rv=latent_hosp,
    I0_rv=I0,
    gen_int_rv=gen_int,
    Rt_process_rv=rtproc,
    hosp_admission_obs_process_rv=obs,
)
```

## Round 2: Incorporating day-of-the-week effects

We will re-use the infection to admission interval and infection to hospitalization rate from the previous model. But we will also add a day-of-the-week effect distribution. To do this, we will create a new instance of `RandomVariable` to model the effect. The class will be based on a truncated normal distribution with a mean of 1.0 and a standard deviation of 0.5. The distribution will be truncated between 0.1 and 10.0. The random variable will be repeated for the number of weeks in the dataset.
Note a similar weekday effect is implemented in its own module, with example code [here](periodic_effects.html).

October 30th, 2023 is a Monday. So we will need to take that into account when building this effect.

```{python}
# | label: weekly-effect
from pyrenew import metaclass
import numpyro as npro


class DayOfWeekEffect(metaclass.RandomVariable):
    """Day of the week effect"""

    def __init__(self, offset: int):
        self.offset = offset

    @staticmethod
    def validate():
        return None

    def sample(self, obs: SampledValue, **kwargs):

        n_timepoints = obs.value.size
        nweeks = ((n_timepoints + self.offset) // 7) + 1

        # Re-computing the offset
        adj = (self.offset + obs.t_start) % 7

        ans = npro.sample(
            name="dayofweek_effect",
            fn=npro.distributions.TruncatedNormal(
                loc=1.0, scale=0.5, low=0.1, high=10.0
            ),
            sample_shape=(7,),
        )

        return (
            metaclass.SampledValue(
                jnp.tile(ans, nweeks)[adj : (n_timepoints + adj)]
            ),
        )


# Initializing the RV.
dayofweek_effect = DayOfWeekEffect(offset=1)  # The data starts 1 day off
```

Notice that the instance's `nweeks` and `len` members are defined during construction. Trying to compute the number of weeks and the length of the dataset in the `validate` method will raise a `jit` error in `jax` as the shape and size of elements are not known during the validation step, which happens before the model is run. With the new effect, we can rebuild the latent hospitalization model:

```{python}
# | label: latent-hosp-weekday
latent_hosp_wday_effect = latent.HospitalAdmissions(
    infection_to_admission_interval_rv=inf_hosp_int,
    infect_hosp_rate_rv=hosp_rate,
    day_of_week_effect_rv=dayofweek_effect,
)

hosp_model_weekday = model.HospitalAdmissionsModel(
    latent_infections_rv=latent_inf,
    latent_hosp_admissions_rv=latent_hosp_wday_effect,
    I0_rv=I0,
    gen_int_rv=gen_int,
    Rt_process_rv=rtproc,
    hosp_admission_obs_process_rv=obs,
)
```

Running the model:

```{python}
# | label: model-2-run
import jax

# Model without weekday effect
hosp_model.run(
    num_samples=2000,
    num_warmup=2000,
    data_observed_hosp_admissions=daily_hosp_admits,
    rng_key=jax.random.PRNGKey(54),
    mcmc_args=dict(progress_bar=False),
)

# Model with weekday effect
hosp_model_weekday.run(
    num_samples=2000,
    num_warmup=2000,
    data_observed_hosp_admissions=daily_hosp_admits,
    rng_key=jax.random.PRNGKey(54),
    mcmc_args=dict(progress_bar=False),
)
```

And plotting the results:

```{python}
# | label: fig-output-admissions
# | fig-cap: Hospital Admissions posterior distribution with weekday effect
import numpy as np

# Figure with weekday effect
out = hosp_model_weekday.plot_posterior(
    var="latent_hospital_admissions",
    ylab="Hospital Admissions",
    obs_signal=np.pad(
        daily_hosp_admits.astype(float),
        (gen_int_array.size, 0),
        constant_values=np.nan,
    ),
)
```

```{python}
# | label: fig-output-admissions-padding-and-weekday
# | fig-cap: Hospital Admissions posterior distribution without weekday effect
out = hosp_model.plot_posterior(
    var="latent_hospital_admissions",
    ylab="Hospital Admissions",
    obs_signal=np.pad(
        daily_hosp_admits.astype(float),
        (gen_int_array.size, 0),
        constant_values=np.nan,
    ),
)
```
