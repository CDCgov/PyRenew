---
title: "Observation processes for continuous measurements"
format: gfm
engine: jupyter
---

This tutorial demonstrates how to use the `Measurements` observation process to model continuous measurement data such as wastewater viral concentrations.

```{python}
# | label: setup
# | output: false
import jax
import jax.numpy as jnp
import numpy as np
import numpyro
import matplotlib.pyplot as plt

from pyrenew.observation import Measurements, HierarchicalNormalNoise
from pyrenew.randomvariable import HierarchicalNormalPrior, GammaGroupSdPrior
from pyrenew.deterministic import DeterministicVariable, DeterministicPMF
```

## Overview

Measurement observation processes model continuous signals derived from infections, such as viral RNA concentrations in wastewater. Unlike count observations (hospital admissions, deaths), measurements are continuous values and in some cases may be negative.

As an example, we'll consider the wastewater viral genome measurement from the [Pyrenew-HEW](https://github.com/cdcgov/pyrenew-hew) family of models. The predicted measurement on day $t$ is:

$$\lambda_t = \frac{G}{V} \cdot \sum_{d=0}^{D} I_{t-d} \cdot p_d$$

where:

- $I_{t-d}$ is the number of incident (new) infections on day $t-d$
- $G$ is a scaling factor (here, genome copies shed per infection)
- $V$ is another scaling factor (here, wastewater volume per person per day)
- $p_d$ is a delay distribution (here, normalized viral genome shedding by time-since-infection)
- $D$ is the maximum duration

Observed log-concentrations are generated by sampling from a normal distribution:

$$\log(C_t) \sim \text{Normal}(\mu = \log(\lambda_t), \sigma)$$

The log-normal distribution is appropriate for concentration data because concentrations are strictly positive and often span several orders of magnitude.

### Comparison with count observations

The core convolution $\sum_{d=0}^{D} I_{t-d} \cdot p_d$ is the same as for count observations. The key differences are:

| Aspect | Counts | Measurements |
|--------|--------|--------------|
| Scaling factor | Ascertainment rate $\alpha \in [0,1]$ | Domain-specific (e.g., $G/V$) |
| Temporal PMF | Delay distribution | Shedding/decay kinetics |
| Output space | Expected counts (linear) | Log-concentrations |
| Noise model | Poisson or Negative Binomial | Normal on log scale |
| Subpop structure | Optional (`CountsBySubpop`) | Inherent (hierarchical effects) |

**Key features of measurement data:**

- **Multiple sites**: Each jurisdiction has several measurement sites (e.g., wastewater treatment plants).
- **Irregular sampling**: Sites measure on different schedules.
- **Site-level variability**: Lab protocols and sampling methods vary across sites.
- **Temporal lag**: Signal peaks several days after infection.

**Note on terminology:** In real-world inference, infections are *latent* (unobserved) and must be estimated from observed data. In this tutorial, we simulate the observation process by specifying infections directly and showing how they produce measurements through convolution and sampling.

## Subclassing Measurements for wastewater

The `Measurements` class is abstract—you must subclass it and implement `_expected_signal()` for your specific signal type. Here we create a `Wastewater` class for viral concentration measurements:

```{python}
# | label: wastewater-class
from jax.typing import ArrayLike
from pyrenew.metaclass import RandomVariable
from pyrenew.observation.noise import MeasurementNoise


class Wastewater(Measurements):
    """
    Wastewater viral concentration observation process.

    Transforms site-level infections into expected log-concentrations
    via shedding kinetics convolution and genome/volume scaling.
    """

    def __init__(
        self,
        shedding_kinetics_rv: RandomVariable,
        log10_genome_per_infection_rv: RandomVariable,
        ml_per_person_per_day: float,
        noise: MeasurementNoise,
    ) -> None:
        """
        Initialize wastewater observation process.

        Parameters
        ----------
        shedding_kinetics_rv : RandomVariable
            Viral shedding PMF (fraction shed each day post-infection).
        log10_genome_per_infection_rv : RandomVariable
            Log10 genome copies shed per infection.
        ml_per_person_per_day : float
            Wastewater volume per person per day (mL).
        noise : MeasurementNoise
            Noise model (e.g., HierarchicalNormalNoise).
        """
        super().__init__(temporal_pmf_rv=shedding_kinetics_rv, noise=noise)
        self.log10_genome_per_infection_rv = log10_genome_per_infection_rv
        self.ml_per_person_per_day = ml_per_person_per_day

    def validate(self) -> None:
        """Validate parameters."""
        shedding_pmf = self.temporal_pmf_rv()
        self._validate_pmf(shedding_pmf, "shedding_kinetics_rv")
        self.noise.validate()

    def lookback_days(self) -> int:
        """Return shedding PMF length."""
        return len(self.temporal_pmf_rv())

    def _expected_signal(self, infections: ArrayLike) -> ArrayLike:
        """
        Compute expected log-concentration from infections.

        Applies shedding kinetics convolution, then scales by
        genome copies and volume to get concentration.
        """
        shedding_pmf = self.temporal_pmf_rv()
        log10_genome = self.log10_genome_per_infection_rv()

        # Convolve each site's infections with shedding kinetics
        def convolve_site(site_infections):
            convolved, _ = self._convolve_with_alignment(
                site_infections, shedding_pmf, p_observed=1.0
            )
            return convolved

        # Apply to all subpops (infections shape: n_days x n_subpops)
        shedding_signal = jax.vmap(convolve_site, in_axes=1, out_axes=1)(
            infections
        )

        # Convert to concentration: genomes per mL
        genome_copies = 10**log10_genome
        concentration = (
            shedding_signal * genome_copies / self.ml_per_person_per_day
        )

        # Return log-concentration (what we model)
        return jnp.log(concentration)
```

## Viral shedding kinetics

The shedding PMF describes what fraction of total viral shedding occurs on each day after infection:

```{python}
# | label: shedding-pmf
# Peak shedding ~3 days after infection, continues for ~10 days
shedding_pmf = jnp.array(
    [0.0, 0.05, 0.15, 0.25, 0.20, 0.15, 0.10, 0.05, 0.03, 0.02]
)
print(f"PMF sums to: {shedding_pmf.sum():.2f}")

shedding_rv = DeterministicPMF("viral_shedding", shedding_pmf)

# Summary statistics
days = np.arange(len(shedding_pmf))
mean_shedding_day = float(np.sum(days * shedding_pmf))
mode_shedding_day = int(np.argmax(shedding_pmf))
print(f"Mode: {mode_shedding_day} days, Mean: {mean_shedding_day:.1f} days")
```

```{python}
# | label: fig-shedding
# | fig-cap: Viral shedding kinetics distribution
fig, ax = plt.subplots(figsize=(8, 4))
ax.bar(days, shedding_pmf, color="steelblue", alpha=0.7, edgecolor="black")
ax.axvline(
    mode_shedding_day,
    color="purple",
    linestyle="-",
    linewidth=2,
    label=f"Mode: {mode_shedding_day}",
)
ax.axvline(
    mean_shedding_day,
    color="red",
    linestyle="--",
    linewidth=2,
    label=f"Mean: {mean_shedding_day:.1f}",
)
ax.set_xlabel("Days after infection")
ax.set_ylabel("Fraction of total shedding")
ax.set_title("Viral Shedding Kinetics")
ax.legend()
plt.tight_layout()
plt.show()
```

## Genome copies and wastewater volume

```{python}
# | label: scaling-params
# Log10 genome copies shed per infection (typical: 8-10)
log10_genome_rv = DeterministicVariable("log10_genome", 9.0)

# Wastewater volume per person per day (mL)
ml_per_person_per_day = 1000.0
```

## Noise model with sensor-level effects

A measurement depends on both the thing being measured (e.g., wastewater from a treatment plant) and the calibration of the lab/instruments used to obtain that measurement. We call this combination a "sensor"—the WWTP/lab pair that determines the measurement characteristics. Different sensors have systematic biases and variabilities that we model with hierarchical effects.

```{python}
# | label: noise-model
# Sensor-level mode: systematic differences between sensors
sensor_mode_prior = HierarchicalNormalPrior(
    name="ww_sensor_mode",
    sd_rv=DeterministicVariable("mode_sd", 0.5),
)

# Sensor-level SD: measurement variability within each sensor
sensor_sd_prior = GammaGroupSdPrior(
    name="ww_sensor_sd",
    sd_mean_rv=DeterministicVariable("sd_mean", 0.3),
    sd_concentration_rv=DeterministicVariable("sd_concentration", 4.0),
    sd_min=0.10,
)

# Create the noise model
ww_noise = HierarchicalNormalNoise(
    sensor_mode_prior_rv=sensor_mode_prior,
    sensor_sd_prior_rv=sensor_sd_prior,
)
```

## Creating the observation process

```{python}
# | label: create-process
ww_process = Wastewater(
    shedding_kinetics_rv=shedding_rv,
    log10_genome_per_infection_rv=log10_genome_rv,
    ml_per_person_per_day=ml_per_person_per_day,
    noise=ww_noise,
)

print(f"Required lookback: {ww_process.lookback_days()} days")
```

### Timeline alignment and lookback period

The observation process convolves infections with a shedding distribution, maintaining alignment between input and output: day $t$ in the output corresponds to day $t$ in the input.

Wastewater concentrations depend on infections from prior days (the length of our shedding distribution minus one). The method `lookback_days()` returns this length; the first valid observation day is at index `lookback - 1`. Earlier days are marked invalid with NaN.

```{python}
# | label: helper-function
def first_valid_observation_day(obs_process) -> int:
    """Return the first day index with complete infection history for convolution."""
    return obs_process.lookback_days() - 1
```

## Simulating wastewater observations from infections

To demonstrate how the observation process works, we simulate concentrations from a spike of infections on a single day.

```{python}
# | label: simulate-spike
n_days = 50

# First valid observation day
day_one = first_valid_observation_day(ww_process)

# Create infections with a spike (shape: n_days x n_subpops)
infection_spike_day = day_one + 10
infections = jnp.zeros((n_days, 1))  # 1 subpopulation
infections = infections.at[infection_spike_day, 0].set(2000.0)

# For plotting
spike_day = infection_spike_day - day_one
n_plot_days = n_days - day_one

# Observation times and indices
observation_days = jnp.arange(day_one, 40, dtype=jnp.int32)
n_obs = len(observation_days)

with numpyro.handlers.seed(rng_seed=42):
    ww_obs = ww_process.sample(
        infections=infections,
        subpop_indices=jnp.zeros(n_obs, dtype=jnp.int32),
        sensor_indices=jnp.zeros(n_obs, dtype=jnp.int32),
        times=observation_days,
        concentrations=None,  # Sample from prior
        n_sensors=1,
    )
```

```{python}
# | label: fig-spike-infections
# | fig-cap: Input infections with a single-day spike
fig, ax = plt.subplots(figsize=(8, 4))
ax.plot(
    np.arange(n_plot_days),
    np.array(infections[day_one:, 0]),
    "-o",
    color="darkblue",
)
ax.axvline(spike_day, color="darkred", linestyle="--", alpha=0.7)
ax.annotate(
    f"Infection spike\n(day {spike_day})",
    xy=(spike_day, 1800),
    xytext=(spike_day + 3, 1800),
    fontsize=10,
    color="darkred",
)
ax.set_xlabel("Day")
ax.set_ylabel("Daily Infections")
ax.set_title("Infections (Input)")
plt.tight_layout()
plt.show()
```

Because all infections occur on a single day, we can see how they spread into wastewater concentrations over subsequent days according to the shedding kinetics.

## Observation noise

The log-normal noise model adds stochastic variation. Sampling multiple times from the same infections shows the range of possible observations:

```{python}
# | label: sample-realizations
n_samples = 50
samples_by_day = {int(d - day_one): [] for d in observation_days}

for seed in range(n_samples):
    with numpyro.handlers.seed(rng_seed=seed):
        ww_result = ww_process.sample(
            infections=infections,
            subpop_indices=jnp.zeros(n_obs, dtype=jnp.int32),
            sensor_indices=jnp.zeros(n_obs, dtype=jnp.int32),
            times=observation_days,
            concentrations=None,
            n_sensors=1,
        )
    for day_idx, conc in zip(observation_days, ww_result.observed):
        samples_by_day[int(day_idx) - day_one].append(float(conc))

# Convert to arrays for plotting
plot_days = sorted(samples_by_day.keys())
all_samples = np.array(
    [[samples_by_day[d][i] for d in plot_days] for i in range(n_samples)]
)
sample_mean = all_samples.mean(axis=0)
```

```{python}
# | label: fig-sampled-concentrations
# | fig-cap: Multiple realizations showing observation noise
fig, ax = plt.subplots(figsize=(8, 4))

# Plot all samples
for i in range(1, n_samples):
    ax.plot(
        plot_days, all_samples[i], color="orange", alpha=0.15, linewidth=0.5
    )

# Highlight one sample
ax.plot(
    plot_days,
    all_samples[0],
    color="steelblue",
    linewidth=1,
    label="One realization",
)

# Sample mean
ax.plot(
    plot_days, sample_mean, color="darkred", linewidth=1.2, label="Sample mean"
)

ax.axvline(spike_day, color="darkblue", linestyle="--", alpha=0.5)
ax.set_xlabel("Day")
ax.set_ylabel("Log Viral Concentration")
ax.set_title(f"Observation Noise: {n_samples} Samples from Same Infections")
ax.legend()
plt.tight_layout()
plt.show()
```

```{python}
# | label: timeline-stats
print("Timeline Analysis:")
print(
    f"  Infection spike on day {spike_day}: {infections[infection_spike_day, 0]:.0f} people"
)
print(
    f"  Mode delay from infection to concentration peak: {mode_shedding_day} days"
)
print(
    f"  Expected concentration peak: day {spike_day + mode_shedding_day} (= {spike_day} + {mode_shedding_day})"
)
```

## Sensor-level variability

Different sensors measuring the same underlying infections will show systematic differences:

```{python}
# | label: multi-sensor
num_sensors = 4
infections_constant = jnp.ones((40, 1)) * 1500.0

# Each sensor samples at multiple time points
times_per_sensor = 10
observation_times = jnp.tile(
    jnp.arange(10, 30, 2, dtype=jnp.int32), num_sensors
)
sensor_ids = jnp.repeat(
    jnp.arange(num_sensors, dtype=jnp.int32), times_per_sensor
)
subpop_ids = jnp.zeros(num_sensors * times_per_sensor, dtype=jnp.int32)

with numpyro.handlers.seed(rng_seed=42):
    ww_multi_sensor = ww_process.sample(
        infections=infections_constant,
        subpop_indices=subpop_ids,
        sensor_indices=sensor_ids,
        times=observation_times,
        concentrations=None,
        n_sensors=num_sensors,
    )
```

```{python}
# | label: fig-multi-sensor
# | fig-cap: Multiple sensors observing the same infections
fig, ax = plt.subplots(figsize=(8, 4))

colors = ["steelblue", "coral", "green", "purple"]
for sensor in range(num_sensors):
    mask = np.array(sensor_ids) == sensor
    ax.plot(
        np.array(observation_times)[mask],
        np.array(ww_multi_sensor.observed)[mask],
        "-o",
        color=colors[sensor],
        label=f"Sensor {sensor}",
    )

ax.set_xlabel("Day")
ax.set_ylabel("Log Viral Concentration")
ax.set_title("Multiple Sensors Observing Same Infections")
ax.legend()
plt.tight_layout()
plt.show()
```

Each sensor has a different baseline concentration (sensor mode) and different measurement variability (sensor SD). The hierarchical model learns these sensor-specific effects during inference.

## Effect of genome shedding parameter

Higher genome shedding means higher observed concentrations:

```{python}
# | label: compare-genome
genome_values = [8.5, 9.0, 9.5, 10.0]
infections_decay = 2000.0 * jnp.exp(-jnp.arange(40) / 15.0)
infections_decay = infections_decay.reshape(-1, 1)

observation_days_cmp = jnp.arange(10, 30, dtype=jnp.int32)
n_obs_cmp = len(observation_days_cmp)

results = {}
for genome_val in genome_values:
    process_temp = Wastewater(
        shedding_kinetics_rv=shedding_rv,
        log10_genome_per_infection_rv=DeterministicVariable(
            "log10_genome", genome_val
        ),
        ml_per_person_per_day=ml_per_person_per_day,
        noise=ww_noise,
    )

    with numpyro.handlers.seed(rng_seed=42):
        ww_temp = process_temp.sample(
            infections=infections_decay,
            subpop_indices=jnp.zeros(n_obs_cmp, dtype=jnp.int32),
            sensor_indices=jnp.zeros(n_obs_cmp, dtype=jnp.int32),
            times=observation_days_cmp,
            concentrations=None,
            n_sensors=1,
        )
    results[genome_val] = np.array(ww_temp.observed)
```

```{python}
# | label: fig-genome-effect
# | fig-cap: Effect of genome shedding parameter on concentrations
fig, ax = plt.subplots(figsize=(8, 4))

colors = ["steelblue", "coral", "green", "purple"]
for (genome_val, conc), color in zip(results.items(), colors):
    ax.plot(
        np.array(observation_days_cmp),
        conc,
        "-o",
        color=color,
        label=f"log10 = {genome_val}",
        markersize=4,
    )

ax.set_xlabel("Day")
ax.set_ylabel("Log Viral Concentration")
ax.set_title("Effect of Genome Shedding Parameter")
ax.legend()
plt.tight_layout()
plt.show()
```

## Multiple subpopulations

In hierarchical models, each sensor serves a distinct subpopulation (catchment area). Different subpopulations can have different infection levels:

```{python}
# | label: multi-subpop
# Two subpopulations with different infection patterns
n_days_mp = 40
infections_subpop1 = 1000.0 * jnp.exp(
    -jnp.arange(n_days_mp) / 20.0
)  # Slow decay
infections_subpop2 = 2000.0 * jnp.exp(
    -jnp.arange(n_days_mp) / 10.0
)  # Fast decay
infections_multi = jnp.stack([infections_subpop1, infections_subpop2], axis=1)

# Two sensors, each observing a different subpopulation
obs_days_mp = jnp.tile(jnp.arange(10, 30, 2, dtype=jnp.int32), 2)
subpop_ids_mp = jnp.array([0] * 10 + [1] * 10, dtype=jnp.int32)
sensor_ids_mp = jnp.array([0] * 10 + [1] * 10, dtype=jnp.int32)

with numpyro.handlers.seed(rng_seed=42):
    ww_multi_subpop = ww_process.sample(
        infections=infections_multi,
        subpop_indices=subpop_ids_mp,
        sensor_indices=sensor_ids_mp,
        times=obs_days_mp,
        concentrations=None,
        n_sensors=2,
    )
```

```{python}
# | label: fig-multi-subpop
# | fig-cap: Sensors observing different subpopulations with different infection dynamics
fig, ax = plt.subplots(figsize=(8, 4))

for subpop in [0, 1]:
    mask = np.array(subpop_ids_mp) == subpop
    ax.plot(
        np.array(obs_days_mp)[mask],
        np.array(ww_multi_subpop.observed)[mask],
        "-o",
        label=f"Subpop {subpop}",
    )

ax.set_xlabel("Day")
ax.set_ylabel("Log Viral Concentration")
ax.set_title("Multiple Subpopulations with Different Infection Dynamics")
ax.legend()
plt.tight_layout()
plt.show()
```
