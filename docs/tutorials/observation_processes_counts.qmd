---
title: "Observation processes for count data"
format: gfm
engine: jupyter
---

This tutorial demonstrates how to use the `Counts` observation process to model count data such as hospital admissions, emergency department visits, or deaths.

```{python}
# | label: setup
# | output: false
import jax.numpy as jnp
import numpy as np
import numpyro
import matplotlib.pyplot as plt

from pyrenew.observation import Counts, NegativeBinomialNoise, PoissonNoise
from pyrenew.deterministic import DeterministicVariable, DeterministicPMF
from pyrenew import datasets
```

## Overview

Count observation processes model the lag between infections and an observed outcome such as hospital admissions, emergency department visits, confirmed cases, or deaths.
Observed data can be aggregated or available as subpopulation-level counts, which are modeled by classes `Counts` and `CountsBySubpop`, respectively.

Count observation processes transform infections into expected observed counts by applying an ascertainment rate and convolving with a delay distribution.

The expected observations on day $t$ are:

$$\lambda_t = \alpha \cdot \sum_{d=0}^{D} I_{t-d} \cdot p_d$$

where:

- $I_{t-d}$ is the number of incident (new) infections on day $t-d$ (i.e., $d$ days before day $t$)
- $\alpha$ is the ascertainment rate (e.g., infection-hospitalization ratio)
- $p_d$ is the delay distribution from infection to observation, conditional on an infection leading to an observation
- $D$ is the maximum delay

Discrete observations are generated by sampling from a noise distribution—either Poisson or negative binomial—to model reporting variability.
Poisson assumes variance equals the mean; negative binomial accommodates the overdispersion common in surveillance data.

**Note on terminology:** In real-world inference, infections are *latent* (unobserved) and must be estimated from observed data like hospital admissions. In this tutorial, we simulate the observation process by specifying infections directly and showing how they produce hospital admissions through convolution and sampling.

## Hospital admissions example

For hospital admissions data, we construct a `Counts` observation process.
The delay is the key mechanism: infections from $d$ days ago ($I_{t-d}$) contribute to today's hospital admissions ($\lambda_t$) weighted by the probability ($p_d$) that an infection leads to hospitalization after exactly $d$ days. The convolution sums these contributions across all past days.

The process generates hospital admissions by sampling from a negative binomial distribution:
$$Y_t \sim \text{NegativeBinomial}(\mu = \lambda_t, \text{concentration} = \phi)$$

The concentration parameter $\phi$ (sometimes called $k$ or the dispersion parameter) controls overdispersion: as $\phi \to \infty$, the distribution approaches Poisson; smaller values allow greater overdispersion.

We use the negative binomial distribution because real-world hospital admission counts exhibit overdispersion—the variance exceeds the mean.
The Poisson distribution assumes variance equals the mean, which is too restrictive. The negative binomial adds an overdispersion term:
$$\text{Var}[Y_t] = \mu + \frac{\mu^2}{\phi}$$

In this example, we use fixed parameter values for illustration; in practice, these parameters would be estimated from data using weakly informative priors.

## Infection-to-hospitalization delay distribution

The delay distribution specifies the probability that an infected person is hospitalized $d$ days after infection, conditional on the infection leading to a hospitalization.
For example, if `hosp_delay_pmf[5] = 0.2`, then 20% of infections that result in hospitalization will appear as hospital admissions 5 days after infection.

We load a delay distribution from PyRenew's datasets:

```{python}
# | label: load-delay
inf_hosp_int = datasets.load_infection_admission_interval()
hosp_delay_pmf = jnp.array(inf_hosp_int["probability_mass"].to_numpy())

delay_rv = DeterministicPMF("inf_to_hosp_delay", hosp_delay_pmf)

# Summary statistics
days = np.arange(len(hosp_delay_pmf))
mean_delay = float(np.sum(days * hosp_delay_pmf))
mode_delay = int(np.argmax(hosp_delay_pmf))
print(f"Mode delay: {mode_delay} days, Mean delay: {mean_delay:.1f} days")
```

```{python}
# | label: fig-delay-distribution
# | fig-cap: Infection-to-hospitalization delay distribution
fig, ax = plt.subplots(figsize=(8, 4))
ax.bar(days, hosp_delay_pmf, color="steelblue", alpha=0.7, edgecolor="black")
ax.axvline(
    mode_delay,
    color="purple",
    linestyle="-",
    linewidth=2,
    label=f"Mode: {mode_delay}",
)
ax.axvline(
    mean_delay,
    color="red",
    linestyle="--",
    linewidth=2,
    label=f"Mean: {mean_delay:.1f}",
)
ax.set_xlabel("Days from infection to hospitalization")
ax.set_ylabel("Probability")
ax.set_title("Infection-to-Hospitalization Delay Distribution")
ax.legend()
plt.tight_layout()
plt.show()
```

## Creating a Counts observation process

A `Counts` object takes the following arguments:

- **`ascertainment_rate_rv`**: the probability an infection results in an observation (e.g., IHR)
- **`delay_distribution_rv`**: delay distribution from infection to observation (PMF)
- **`noise`**: noise model (`PoissonNoise()` or `NegativeBinomialNoise(concentration_rv)`)

```{python}
# | label: create-counts-process
# Infection-hospitalization ratio (1% of infections lead to hospitalization)
ihr_rv = DeterministicVariable("ihr", 0.01)

# Overdispersion parameter for negative binomial
concentration_rv = DeterministicVariable("concentration", 10.0)

# Create the observation process
hosp_process = Counts(
    ascertainment_rate_rv=ihr_rv,
    delay_distribution_rv=delay_rv,
    noise=NegativeBinomialNoise(concentration_rv),
)

print(f"Required lookback: {hosp_process.lookback_days()} days")
```

### Timeline alignment and lookback period

The observation process convolves infections with a delay distribution, maintaining alignment between input and output: day $t$ in the output corresponds to day $t$ in the input.

Hospital admissions depend on infections from prior days (the length of our delay distribution minus one). The method `lookback_days()` returns this length; the first valid observation day is at index `lookback - 1`. Earlier days are marked invalid.

```{python}
# | label: helper-function
def first_valid_observation_day(obs_process) -> int:
    """Return the first day index with complete infection history for convolution."""
    return obs_process.lookback_days() - 1
```

## Simulating hospital admissions from infections

To demonstrate how the observation process works, we simulate admissions from a spike of infections on a single day.

```{python}
# | label: simulate-spike
n_days = 100
lookback = hosp_process.lookback_days()

# First valid observation day
day_one = lookback - 1

# Create infections with a spike
infection_spike_day = day_one + 10
infections = jnp.zeros(n_days)
infections = infections.at[infection_spike_day].set(2000)

# Sample hospital admissions
with numpyro.handlers.seed(rng_seed=42):
    hosp_admissions = hosp_process.sample(
        infections=infections,
        counts=None,  # Sample from prior (no observed data)
    )
```

```{python}
# | label: fig-spike-infections
# | fig-cap: Input infections with a single-day spike
# Plot relative to first valid observation day
spike_day = infection_spike_day - day_one
n_plot_days = n_days - day_one

fig, ax = plt.subplots(figsize=(8, 4))
ax.plot(
    np.arange(n_plot_days),
    np.array(infections[day_one:]),
    "-o",
    color="darkblue",
)
ax.axvline(spike_day, color="darkred", linestyle="--", alpha=0.7)
ax.annotate(
    f"Infection spike\n(day {spike_day})",
    xy=(spike_day, 1800),
    xytext=(spike_day + 5, 1800),
    fontsize=10,
    color="darkred",
)
ax.set_xlabel("Day")
ax.set_ylabel("Daily Infections")
ax.set_title("Infections (Input)")
plt.tight_layout()
plt.show()
```

Because all infections occur on a single day, we can see how they spread into hospital admissions over subsequent days according to the delay distribution:

```{python}
# | label: fig-spike-admissions
# | fig-cap: Hospital admissions from a single-day infection spike
fig, ax = plt.subplots(figsize=(8, 4))
ax.plot(
    np.arange(n_plot_days),
    np.array(hosp_admissions.observed[day_one:]),
    "-o",
    color="purple",
)
ax.axvline(
    spike_day,
    color="darkred",
    linestyle="--",
    alpha=0.5,
    label="Infection spike",
)
ax.axvline(
    spike_day + mode_delay,
    color="purple",
    linestyle="--",
    alpha=0.5,
    label="Peak admissions",
)
ax.set_xlabel("Day")
ax.set_ylabel("Hospital Admissions")
ax.set_title("Hospital Admissions (Output)")
ax.legend()
plt.tight_layout()
plt.show()
```

The admissions peak occurs `{python} mode_delay` days after the infection spike, matching the mode of the delay distribution.

## Observation noise

The negative binomial distribution adds stochastic variation. Sampling multiple times from the same infections shows the range of possible observations:

```{python}
# | label: sample-realizations
n_samples = 50
samples = []

for seed in range(n_samples):
    with numpyro.handlers.seed(rng_seed=seed):
        result = hosp_process.sample(infections=infections, counts=None)
    samples.append(np.array(result.observed[day_one:]))

samples = np.array(samples)
sample_mean = samples.mean(axis=0)
```

```{python}
# | label: fig-sampled-admissions
# | fig-cap: Multiple realizations showing observation noise
fig, ax = plt.subplots(figsize=(8, 4))

# Plot all samples in light orange
for i in range(1, n_samples):
    ax.plot(
        np.arange(n_plot_days),
        samples[i],
        color="orange",
        alpha=0.15,
        linewidth=0.5,
    )

# Highlight one sample
ax.plot(
    np.arange(n_plot_days),
    samples[0],
    color="steelblue",
    linewidth=1,
    label="One realization",
)

# Sample mean
ax.plot(
    np.arange(n_plot_days),
    sample_mean,
    color="darkred",
    linewidth=1.2,
    label="Sample mean",
)

ax.axvline(spike_day, color="darkblue", linestyle="--", alpha=0.5)
ax.set_xlabel("Day")
ax.set_ylabel("Hospital Admissions")
ax.set_title(f"Observation Noise: {n_samples} Samples from Same Infections")
ax.legend()
plt.tight_layout()
plt.show()
```

```{python}
# | label: timeline-stats
# Print timeline statistics
print("Timeline Analysis:")
print(
    f"  Infection spike on day {spike_day}: {infections[infection_spike_day]:.0f} people"
)
print(f"  Mode delay from infection to hospitalization: {mode_delay} days")
print(
    f"  Expected hospitalization peak: day {spike_day + mode_delay} (= {spike_day} + {mode_delay})"
)
```

## Effect of the ascertainment rate

The ascertainment rate directly scales expected hospital admissions. We compare IHR values of 0.5% and 2.5%:

```{python}
# | label: compare-ihr
ihr_values = [0.005, 0.025]
infections_decay = 3000 * jnp.exp(-jnp.arange(n_days) / 20.0)

results = {}
for ihr_val in ihr_values:
    process = Counts(
        ascertainment_rate_rv=DeterministicVariable("ihr", ihr_val),
        delay_distribution_rv=delay_rv,
        noise=NegativeBinomialNoise(concentration_rv),
    )
    # Average over multiple samples to show the effect on the mean
    samples = []
    for seed in range(20):
        with numpyro.handlers.seed(rng_seed=seed):
            result = process.sample(infections=infections_decay, counts=None)
        samples.append(np.array(result.observed[day_one:]))
    results[ihr_val] = np.mean(samples, axis=0)
```

```{python}
# | label: fig-ihr-comparison
# | fig-cap: Effect of different infection-hospitalization rates
fig, ax = plt.subplots(figsize=(8, 4))
colors = ["steelblue", "darkred"]

for (ihr_val, mean_sample), color in zip(results.items(), colors):
    ax.plot(
        np.arange(n_plot_days),
        mean_sample,
        color=color,
        linewidth=1.5,
        label=f"IHR = {ihr_val:.1%}",
    )

ax.set_xlabel("Day")
ax.set_ylabel("Hospital Admissions (mean of samples)")
ax.set_title("Effect of IHR on Hospital Admissions")
ax.legend()
plt.tight_layout()
plt.show()
```

## Negative binomial concentration parameter

The concentration parameter $\phi$ controls overdispersion:

- Higher $\phi$ → less overdispersion (approaches Poisson)
- Lower $\phi$ → more overdispersion (noisier data)

```{python}
# | label: fig-concentration-comparison
# | fig-cap: Effect of concentration parameter on variability
infections_constant = 2000 * jnp.ones(n_days)
concentration_values = [1.0, 10.0, 100.0]
n_replicates = 10

fig, axes = plt.subplots(1, 3, figsize=(12, 4), sharey=True)

for ax, conc_val in zip(axes, concentration_values):
    process = Counts(
        ascertainment_rate_rv=ihr_rv,
        delay_distribution_rv=delay_rv,
        noise=NegativeBinomialNoise(DeterministicVariable("conc", conc_val)),
    )

    for seed in range(n_replicates):
        with numpyro.handlers.seed(rng_seed=seed):
            result = process.sample(
                infections=infections_constant, counts=None
            )
        ax.plot(
            np.arange(n_plot_days),
            np.array(result.observed[day_one:]),
            color="steelblue",
            alpha=0.5,
            linewidth=0.8,
        )

    ax.set_xlabel("Day")
    ax.set_title(f"φ = {int(conc_val)}")

axes[0].set_ylabel("Hospital Admissions")
fig.suptitle("Effect of Concentration Parameter on Variability")
plt.tight_layout()
plt.show()
```

## Swapping noise models

To use Poisson noise instead of negative binomial, change the noise model:

```{python}
# | label: poisson-noise
hosp_process_poisson = Counts(
    ascertainment_rate_rv=ihr_rv,
    delay_distribution_rv=delay_rv,
    noise=PoissonNoise(),
)

with numpyro.handlers.seed(rng_seed=42):
    poisson_result = hosp_process_poisson.sample(
        infections=infections,
        counts=None,
    )

print(
    f"Sampled {len(poisson_result.observed)} days of hospital admissions with Poisson noise"
)
```
