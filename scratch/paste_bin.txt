
NOTES


seeding ("initialization" in MSR lingo):

 no renewal process, no need for a defined R(t)

pre-observation: renewal process in progress but we set observed hosps to zero and set alpha ~= 0 to allow the process to "warm up"


observation: renewal process in progress, alpha â‰  0, and observed hosps have values, so they are used for inference


Look to Admission Model for inspiration for sample().


REMOVE infections, fix co-code (3)

class CFAEPIM_Infections(RandomVariable):  # numpydoc ignore=GL08
    @staticmethod
    def validate() -> None:  # numpydoc ignore=GL08
        return None

    def sample(
        self, Rt: ArrayLike, gen_int: ArrayLike, P: float, **kwargs
    ) -> tuple:  # numpydoc ignore=GL08
        I0_samples = self.I0.sample()
        I0 = I0_samples[0].value
        if I0.size < gen_int.size:
            raise ValueError(
                "Initial infections vector must be at least as long as "
                "the generation interval. "
                f"Initial infections vector length: {I0.size}, "
                f"generation interval length: {gen_int.size}."
            )
        gen_int_rev = jnp.flip(gen_int)
        recent_I0 = I0[-gen_int_rev.size :]
        all_infections = compute_infections_from_rt(
            I0=recent_I0,
            Rt=Rt,
            reversed_generation_interval_pmf=gen_int_rev,
        )
        S_t = jnp.zeros_like(all_infections)
        S_t = S_t.at[0].set(P)  # initial P

        # update: avoid set as much as possible
        # update: hstack(); can be changed uniformly later
        # update: per DB's update, use numpyro.contrib.flow something scan
        def update_infections(carry, x):  # numpydoc ignore=GL08
            S_prev, I_prev = carry
            Rt, gen_int_rev_t = x
            # update: ^ not actually the backwards looking convolve desired
            # verify this; use fixed value for gen_int doesn't need to change;
            # could work if you want a time varying generation interval;
            i_raw_t = Rt * jnp.dot(I_prev, gen_int_rev_t)
            i_t = logistic_susceptibility_adjustment(i_raw_t, S_prev / P, P)
            S_t = S_prev - i_t
            I_prev = jnp.roll(I_prev, -1)
            I_prev = I_prev.at[-1].set(i_t)
            return (S_t, I_prev), i_t

        # confirm: update this to set prior on S_{v-1} / P
        # update: the prior will change init_carry, [0, P]
        init_carry = (P, recent_I0)
        Rt_gen_int_rev = jnp.stack(
            [Rt, jnp.tile(gen_int_rev, (Rt.size, 1))], axis=-1
        )
        (_, all_S_t), all_I_t = jax.lax.scan(
            update_infections, init_carry, Rt_gen_int_rev
        )
        # update: realized Rt is a consequence of the sus. adjustment
        # Epidemia does not document this well.
        return all_I_t, all_S_t



REMOVE doc string for now, co-code (2)

    """
    The `cfaepim` model. Its properties are derived
    from the configuration file provided. Forecasts
    for a single state can be made using the model.
    The fundamental question, for each part of
    `cfaepim`, comes in asking whether a component
    ought to made in base MSR or made custom in MSR.
    Remember some parameters, e.g. first_fitting_date,
    are already accounted for in the data that has
    been made available.
    """


REMOVE I0 structure, co-code (2)



"attempt at transmforming to get exponentially dist"

# infections:  initialized infections
# rate_RV = DeterministicVariable(name="rate_RV", value=0.5)
# I_pre_init_RV = DeterministicVariable(name="I_pre_init_RV", value=10.0)
# default_t_pre_init = n_timepoints - 1

# (I_pre_init,) = I_pre_init_RV()
# (rate,) = rate_RV()

# I_pre_init = I_pre_init.value
# rate = rate.value
# infections_default_t_pre_init = InitializeInfectionsExponentialGrowth(
#     n_timepoints, rate=rate_RV
# ).initialize_infections(I_pre_init)

self.I0 = TransformedRandomVariable(
    name="transformed_I0",
    base_rv=self.I0,
    transforms=dist.Exponential(rate=1/mean_inf_val)
)

and

# update: compute from data, to match `cfaepim`
        # update: then replace with thing that is better
        # FromVec, drawn as IID exp. len N
        # update: update, inf_model_seed_days = 8
        self.lambda_I0 = 0.1
        self.I0 = InfectionInitializationProcess(
            name="I0_initialization",
            I_pre_init_rv=DistributionalRV(
                name="I0",
                dist=DeterministicVariable(
                    name="I_pre_init_RV", value=self.lambda_I0
                ),
            ),
            infection_init_method=InitializeInfectionsExponential(
                n_timepoints=self.inf_model_seed_days,
                rate=DistributionalRV(
                    name="rate", dist=dist.Exponential(self.lambda_I0)
                ),
            ),
            t_unit=1,
        )
        #
        # update: seeding, pre_obs, obs
        # update: init_period (8), post_init_pre_obs (14) renewal process with no observation (no random walk on Rt, fixed), obs_period
        # update: make issue on InitializationProcess & ...Method classes
        # and their use; write up some suggestions.
        # 22 days before observation



REMOVE Observation structure, co-code (2)

day_of_week_priors = dist.Normal(
            jnp.array(self.day_of_week_effect_prior_modes),
            jnp.array(self.day_of_week_effect_prior_scales),
        ).expand([len(self.day_of_week_effect_prior_modes)])
        holiday_prior = dist.Normal(
            self.holiday_eff_prior_mode, self.holiday_eff_prior_scale
        ).expand([1])
        post_holiday_prior = dist.Normal(
            self.post_holiday_eff_prior_mode, self.post_holiday_eff_prior_scale
        ).expand([1])
        pre_observation_prior = dist.Normal(
            self.non_obs_effect_prior_mode, self.non_obs_effect_prior_scale
        ).expand([1])
        coefficient_priors = [
            day_of_week_priors,
            holiday_prior,
            post_holiday_prior,
            pre_observation_prior
        ]
        all_coefficient_priors = dist.Normal(
            loc=jnp.array([prior.mean for prior in coefficient_priors]),
            scale=jnp.array([prior.variance for prior in coefficient_priors]) ** 0.5
        )


REMOVE I0 initialization, co-code (1)

self.I0 = InfectionInitializationProcess(
            "I0_initialization",
            I_pre_init_rv=DistributionalRV(
                name="I0",
                dist=dist.LogNormal(
                    loc=jnp.log(100), scale=jnp.log(1.75)),
            ),  # confirm: need to change from tutoral values
            infection_init_method=InitializeInfectionsExponentialGrowth(
                n_timepoints=self.n_pre_observation_days,
                rate=DeterministicVariable(
                    name="rate", value=0.05),
            ),  # update: initialize infection vector w/ exp DISTRIBUTED vector
            t_unit=1,
        )


REMOVE run method, co-code (1)

def run(self, **kwargs):  # numpydoc ignore=GL08
        kernel = numpyro.infer.NUTS(
            model=self.model,
            step_size=self.adapt_delta,
            max_tree_depth=self.max_treedepth,
        )
        mcmc = numpyro.infer.MCMC(
            sampler=kernel,
            num_warmup=self.n_warmup,
            num_samples=self.n_iter,
            num_chains=self.n_chains,
        )
        mcmc.run(
            rng_key=jax.random.PRNGKey(self.seed),
            data_observed_hosp_admissions=self.data_observed_hosp_admissions,
        )
        mcmc.print_summary()
        self.mcmc = mcmc
        # update: defer to metaclass for model + run
        # update: represent data_observed_hosp_admissions as an attribute,
        # but not as an instance attributes; pass this to the.
        # "a model should have as few numbers as it in possible"
        # "any numbers that the model sees should be passed in at run time"
        # "config should be seen at run time"


REMOVE _init_observation_component, co-code (1)


def _init_observation_component(self):  # numpydoc ignore=GL08
        # update: connect w/ alpha
        # update: combine w/ alpha as a class
        # update this; remove extraneous; rename; add reciprocal dispersion
        nb_conc_rv = TransformedRandomVariable(
            "concentration",
            base_rv=DistributionalRV(
                name="concentration_raw",
                dist=dist.Normal(0, 1)
            ),
            transforms=t.ScaledLogitTransform(x_max=self.max_rt),
        )
        self.admissions = NegativeBinomialObservation(
            name="hospital_admissions", concentration_rv=nb_conc_rv
        )

REMOVE _init_alpha, co-code (1)

def _init_alpha_t(self):  # numpydoc ignore=GL08
        predictor_values = self.predictors
        alpha_intercept_prior = dist.Normal(
            self.ihr_intercept_prior_mode, self.ihr_intercept_prior_scale
        )
        day_of_week_priors = dist.Normal(0, 0.25).expand([6])
        holiday_prior = dist.Normal(
            self.holiday_eff_prior_mode, self.holiday_eff_prior_scale
        ).expand([1])
        post_holiday_prior = dist.Normal(
            self.post_holiday_eff_prior_mode, self.post_holiday_eff_prior_scale
        ).expand([1])
        pre_observation_prior = dist.Normal(
            self.non_obs_effect_prior_mode, self.non_obs_effect_prior_mode
        ).expand([1])
        all_coefficient_priors = jnp.concatenate(
            [
                day_of_week_priors,
                holiday_prior,
                post_holiday_prior,
                pre_observation_prior,
            ]
        )
        self.alpha_process = GLMPrediction(
            name="alpha_t",
            fixed_predictor_values=predictor_values,
            intercept_prior=alpha_intercept_prior,
            coefficient_priors=all_coefficient_priors,
            transform=t.ScaledLogitTransform(x_max=self.max_rt),
        )  # update: make this into its own class


REMOVED CFAEPIM_Rt, co-code (1)

class CFAEPIM_Rt(RandomVariable):  # numpydoc ignore=GL08
    def __init__(
        self, intercept_RW_prior, max_rt, gamma_RW_prior, gamma_RW_prior_scale
    ):  # numpydoc ignore=GL08
        self.intercept_RW_prior = intercept_RW_prior
        self.max_rt = max_rt
        self.gamma_RW_prior = gamma_RW_prior
        self.gamma_RW_prior_scale = gamma_RW_prior_scale

    @staticmethod
    def validate() -> None:  # numpydoc ignore=GL08
        pass

    def sample(self, n_steps: int, **kwargs) -> tuple:  # numpydoc ignore=GL08
        glm = GLMPrediction(
            name="CFAEPIM_Rt_GLM",
            fixed_predictor_values=jnp.ones((n_steps, 1)),  # intercept & RW
            intercept_prior=self.intercept_RW_prior,
            coefficient_priors=self.gamma_RW_prior,
            transform=t.ScaledLogitTransform(x_max=self.max_rt),
        )
        # update: Epidemia does this all as GLM under the hood,
        # but epimlight model just has Rt intercept & random walk
        # update: intercept can just be part of RtWalk, simple random
        # walk can be transformed using scaled logit, init_rv = intercept
        # prior, sd_wt (as you've done). These needs to be broadcast from
        # weekly to daily.
        eta_samples = glm.sample()
        sd_wt = numpyro.sample("Wt_rw_sd", dist.gamma_RW_prior_scale)
        wt_rv = SimpleRandomWalkProcess(
            name="Wt",
            step_rv=DistributionalRV(
                name="rw_step_rv",
                dist=dist.Normal(0, sd_wt),  # confirm: should I reuse
                reparam=LocScaleReparam(0),  # confirm: thoughts on this?
            ),
            init_rv=DistributionalRV(
                name="init_Wt_rv",
                dist=dist.Normal(
                    0, 1
                ),  # confirm: not sure what else to put here
            ),
        )
        wt_samples = wt_rv.sample(n_steps=n_steps, **kwargs)
        rt_samples = eta_samples["prediction"] + wt_samples[0].value
        # update: don't want scaled logit twice, remove GLM section;
        transformed_rt_samples = t.ScaledLogitTransform(x_max=self.max_rt)(
            rt_samples
        )
        return transformed_rt_samples

    # update: broadcast weekly to daily
